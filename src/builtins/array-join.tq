// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module array {
  // Naming convention from elements.cc. We have a similar intent but implement
  // fastpaths using generics instead of using a class hierarchy for elements
  // kinds specific implementations.
  type GenericElementsAccessor;
  type FastHoleyObjectElements;
  type FastHoleyDoubleElements;
  type DictionaryElements;

  macro Load<ElementsAccessor: type>(
      context: Context, elements: HeapObject, index: intptr): Object
  labels IfHole {
    assert(IsFixedArraySubclass(elements));
    let fa: FixedArray = unsafe_cast<FixedArray>(elements);
    let el: Object = fa[index];
    if (IsTheHole(el)) goto IfHole;
    return el;
  }

  Load<GenericElementsAccessor>(
      context: Context, elements: HeapObject, index: intptr): Object
  labels IfHole {
    return GetProperty(context, elements, IntPtrToNumberArrayIndex(index));
  }

  Load<FastHoleyDoubleElements>(
      context: Context, elements: HeapObject, index: intptr): Object
  labels IfHole {
    assert(IsFixedDoubleArray(elements));
    let fda: FixedDoubleArray = unsafe_cast<FixedDoubleArray>(elements);
    let el: float64 = LoadDoubleWithHoleCheck(fda, index) otherwise IfHole;
    return AllocateHeapNumberWithValue(el);
  }

  type UseToString;
  type UseToLocaleString;

  macro IsUseToLocaleString<ToStringStrategy: type>(): constexpr bool {
    return false;
  }

  IsUseToLocaleString<UseToLocaleString>(): constexpr bool {
    return true;
  }

  macro JoinToLocaleString(context: Context, element: Object): never
  labels IfEmpty, IfString(String), IfStringWithSideEffects(String) {
    if (IsNullOrUndefined(element)) goto IfEmpty;

    let prop: Object = GetProperty(context, element, 'toLocaleString');
    try {
      let callable: Callable = cast<Callable>(prop) otherwise TypeError;
      let result: Object = ToString(context, Call(context, callable, element));
      goto IfStringWithSideEffects(unsafe_cast<String>(result));
    }
    label TypeError {
      ThrowTypeError(context, kCalledNonCallable, prop);
    }
  }

  // Specialized ToString() for Array.p.join(), allowing optimized handling for
  // the following cases...
  //  IfEmpty:                 null or undefined
  //  IfString:                converted to a string with no side-effects
  //  IfStringWithSideEffects: converted to a string with possible side-effects
  //                           (JS code may have been called during conversion)
  macro JoinToString<ElementsAccessor: type>(
      context: Context, element: Object): never
  labels IfEmpty, IfString(String), IfStringWithSideEffects(String) {
    if (TaggedIsSmi(element)) {
      goto IfString(SmiToString(unsafe_cast<Smi>(element)));
    }

    let elementObj: HeapObject = unsafe_cast<HeapObject>(element);
    if (IsString(elementObj)) {
      goto IfString(unsafe_cast<String>(element));
    } else if (IsHeapNumber(elementObj)) {
      goto IfString(HeapNumberToString(unsafe_cast<HeapNumber>(element)));
    } else if (IsNullOrUndefined(element)) {
      goto IfEmpty;
    } else {
      // TODO(pwong): Mark this branch as 'unlikely' for performance improvement
      // (5-10%), when Torque has the ability to mark a branch 'kDeferred'.
      goto IfStringWithSideEffects(ToString(context, element));
    }
  }

  JoinToString<FastHoleyDoubleElements>(
      context: Context, element: Object): never
  labels IfEmpty, IfString(String), IfStringWithSideEffects(String) {
    goto IfString(HeapNumberToString(unsafe_cast<HeapNumber>(element)));
  }

  // Verifies the current element accessor can still be safely used
  // (see Load<ElementsAccessor>). As an optimization, this is only called when
  // ToString() may have had side-effects (see
  // JoinToString<ElementsAccessor> label IfStringWithSideEffects).
  macro CannotUseSameAccessor<ElementsAccessor: type>(
      originalMap: Object, originalLen: Object, receiver: JSReceiver): never
  labels Cannot, Can {
    let array: JSArray = unsafe_cast<JSArray>(receiver);
    if (originalMap != array.map) goto Cannot;
    if (originalLen != array.length) goto Cannot;
    if (IsNoElementsProtectorCellInvalid()) goto Cannot;
    goto Can;
  }

  CannotUseSameAccessor<GenericElementsAccessor>(
      originalMap: Object, originalLen: Object, receiver: JSReceiver): never
  labels Cannot, Can {
    // The GenericElementsAccessor element accessor is designed to handle all
    // cases when loading an element from a receiver (see
    // Load<GenericElementsAccessor>).
    goto Can;
  }

  CannotUseSameAccessor<DictionaryElements>(
      originalMap: Object, originalLen: Object, receiver: JSReceiver): never
  labels Cannot, Can {
    // To simplify the specialization of dictionary elements, we simply bailout
    // if any dictionary element called JS code during `ToString`.
    // TODO(pwong): Optimize dictionary elements that implement toString().
    // TODO(pwong): This useless identity check is to fake out Torque so it can
    // generate the Can (else branch) in ArrayJoinImpl.
    if (receiver == receiver) goto Cannot;
    goto Can;
  }

  macro ArrayJoinImpl<ElementsAccessor: type, ToStringStrategy: type>(
      context: Context, receiver: JSReceiver, elements: HeapObject,
      elementsLen: intptr, sep: String, initialString: String,
      initialIndex: intptr, initialLen: Number, initialMap: Object): String
  labels Continuation(intptr, String) {
    // 5. Let R be the empty String.
    let r: String = initialString;

    // 6. Let k be 0.
    // 7. Repeat, while k < len
    for (let k: intptr = initialIndex; k < elementsLen; k++) {
      try {
        // a. If k > 0, let R be the string-concatenation of R and sep.
        if (k > 0) {
          r = StringAdd_CheckNone_NotTenured(context, r, sep);
        }

        // b. Let element be ? Get(O, ! ToString(k)).
        let element: Object =
          Load<ElementsAccessor>(context, elements, k) otherwise Skip;

        // c. If element is undefined or null, let next be the empty String;
        //    otherwise, let next be ? ToString(element).
        if constexpr (IsUseToLocaleString<ToStringStrategy>()) {
          JoinToLocaleString(context, element)
          otherwise Skip, IfString, IfStringWithSideEffects;
        } else {
          JoinToString<ElementsAccessor>(context, element)
          otherwise Skip, IfString, IfStringWithSideEffects;
        }
      }
      label IfString(next: String) {
        // d. Set R to the string-concatenation of R and next.
        r = StringAdd_CheckNone_NotTenured(context, r, next);
      }
      label IfStringWithSideEffects(next: String) {
        // d. Set R to the string-concatenation of R and next.
        r = StringAdd_CheckNone_NotTenured(context, r, next);

        if (CannotUseSameAccessor<ElementsAccessor>(initialMap, initialLen,
                                                    receiver)) {
          goto Continuation(k + 1, r);
        }
      }
      label Skip {}

      // e. Increment k by 1.
    }

    // 8. Return R.
    return r;
  }

  builtin ArrayJoinContinuation<ToStringStrategy: type>(
      context: Context, receiver: JSReceiver, sep: String, len: Number,
      initialString: String, initialIndex: Number): Object {
    try {
      let initialIndexInt: intptr = NumberArrayIndexToIntPtr(initialIndex);
      let lenInt: intptr = NumberArrayIndexToIntPtr(len);
      return ArrayJoinImpl<GenericElementsAccessor, UseToLocaleString>(
        context, receiver, receiver, lenInt, sep, initialString,
        initialIndexInt, len, Undefined)
      otherwise Continuation;
    }
    label Continuation(i: intptr, r: String) {
      // The GenericElementsAccessor element accessor is designed to handle all
      // cases and never bails out (see Load<GenericElementsAccessor>).
      unreachable;
    }
  }

  // TODO(pwong): Measure performance impact of using GetLengthProperty (array.tq)
  macro GetPropertyLength(context: Context, obj: HeapObject): Number {
    if (IsJSArray(obj)) {
      let array: JSArray = unsafe_cast<JSArray>(obj);
      return array.length;
    } else {
      let lenObj: Object = GetProperty(context, obj, LengthString);
      return ToLength_Inline(context, lenObj);
    }
  }

  macro IsSparseDictionary(context: Context, array: JSArray,
                           len: intptr): bool {
    assert(IsNumberDictionary(array.elements));
    let elements: NumberDictionary =
      unsafe_cast<NumberDictionary>(array.elements);
    let estimated_nof: intptr =
      convert<intptr>(GetNumberDictionaryNumberOfElements(elements));

    // No more than 75% holes
    return estimated_nof < (len >> 2);
  }

  macro NumberArrayIndexToIntPtr(i: Number): intptr {
    assert(IsNumberArrayIndex(i));
    return Signed(convert<uintptr>(i));
  }

  macro IntPtrToNumberArrayIndex(i: intptr): Number {
    assert(i < Signed(convert<uintptr>(from_constexpr<uint32>(kMaxArrayIndex))));
    if (IsValidPositiveSmi(i)) return convert<Smi>(i);
    let f: float64 = RoundIntPtrToFloat64(i);
    return AllocateHeapNumberWithValue(f);
  }

  // TODO(pwong): moves this down
  extern macro CallCCollectNumberDictionaryElementIndices(JSArray): FixedArray;

  builtin ArrayJoin<ToStringStrategy: type>(
      context: Context, receiver: JSReceiver, len: Number,
      sep: String): Object {
    try {
      let map: Map = receiver.map;
      let kind: ElementsKind = map.elements_kind;

      if (IsJSArrayMap(map)) {
        assert(IsJSArray(receiver));
        let array: JSArray = unsafe_cast<JSArray>(receiver);
        let arrayLen: Object = array.length;
        let lenInt: intptr = NumberArrayIndexToIntPtr(len);

        if (arrayLen == len &&
            IsPrototypeInitialArrayPrototype(context, map) &&
            !IsNoElementsProtectorCellInvalid()) {
          if (kind <= HOLEY_ELEMENTS) {
            return ArrayJoinImpl<FastHoleyObjectElements, ToStringStrategy>(
              context, array, array.elements, lenInt, sep, EmptyString, 0, len, map)
            otherwise Continuation;
          } else if (kind <= HOLEY_DOUBLE_ELEMENTS) {
            return ArrayJoinImpl<FastHoleyDoubleElements, ToStringStrategy>(
              context, array, array.elements, lenInt, sep, EmptyString, 0, len, map)
            otherwise Continuation;
          }
        }

        if (kind == DICTIONARY_ELEMENTS &&
            IsEmptyString(sep) &&
            HasComplexElements(context, array) == False &&
            IsSparseDictionary(context, array, lenInt)) {
          // TODO(pwong): Seperate this out in it's own commit (still need to figure out how to handle side-effectful ToString dictionay elements)
          // TODO(pwong): Write a test to verify concern that elements may move?
          // CallCCollectNumberDictionaryElementIndices allocates memory and a
          // GC may cause array elements to move.
          let indices: FixedArray =
            CallCCollectNumberDictionaryElementIndices(array);
          let indicesLen: intptr = indices.length_intptr;
          if (indicesLen == 0) return EmptyString;

          let values: FixedArray =
            AllocateFixedArray(PACKED_ELEMENTS, indicesLen);
          for (let i: intptr = 0; i < indicesLen; i++) {
            values[i] = GetProperty(context, receiver, indices[i]);
          }

          try {
            return ArrayJoinImpl<DictionaryElements, ToStringStrategy>(
              context, array, values, indicesLen, sep, EmptyString, 0, len, map)
            otherwise DictionaryContinuation;
          }
          label DictionaryContinuation(i: intptr, r: String) {
            let index: Object = indices[i - 1];
            assert(IsNumber(index));
            let indexInt: intptr =
              NumberArrayIndexToIntPtr(unsafe_cast<Number>(index));
            goto Continuation(indexInt + 1, r);
          }
        }
      }
      goto Continuation(0, EmptyString);
    }
    label Continuation(i: intptr, r: String) {
      return ArrayJoinContinuation<ToStringStrategy>(
        context, receiver, sep, len, r, IntPtrToNumberArrayIndex(i));
    }
  }

  // The Join Stack detects cyclical calls to Array.p.join.  This FixedArray
  // holds a stack of JSArrays that are receivers to the current call
  // to Array.p.join. The Array.p.join builtin is responsible for calling
  // JoinStackPush and JoinStackPop when visiting and leaving a JSArray,
  // respectively.
  extern macro LoadJoinStack(): FixedArray;
  extern macro SetJoinStack(FixedArray): void;
  const kMinJoinStackSize: constexpr int32 generates
  'JSArray::kMinJoinStackSize';
  const kMaxArrayIndex: constexpr uint32 generates
  'JSArray::kMaxArrayIndex';

  // Adds a receiver to the stack. The FixedArray will automaticlly grow to
  // accomadate the receiver. If the receiver already exists on the stack,
  // this indicates a cyclical call and False is returned.
  builtin JoinStackPush(
      context: Context, stack: FixedArray, receiver: Object): Boolean {
    let len: intptr = stack.length_intptr;
    for (let i: intptr = 0; i < len; i++) {
      let previouslyVisited: Object = stack[i];

      // Add `receiver` to the first open slot
      if (previouslyVisited == Hole) {
        stack[i] = receiver;
        return True;
      }

      // Detect cycles
      if (receiver == previouslyVisited) return False;
    }

    // If no open slots were found, grow the stack and add receiver to the end.
    // Growth rate is analog to JSObject::NewElementsCapacity:
    // new_capacity = (current_capacity + (current_capacity >> 1)) + 16.
    let capacity: intptr = (len + (len >>> 1)) + 16;
    let newStack: FixedArray =
        ExtractFixedArray(stack, 0, len, capacity, kFixedArrays);
    newStack[len] = receiver;
    SetJoinStack(newStack);
    return True;
  }

  macro JoinStackPush_Inline(context: Context, receiver: Object)
  labels CycleDetected {
    let stack: FixedArray = LoadJoinStack();
    assert(stack.length_intptr >= kMinJoinStackSize);

    // Fast path the common non-nested join call case.
    if (stack[0] == Hole) {
      stack[0] = receiver;
    } else if (JoinStackPush(context, stack, receiver) == False) {
      goto CycleDetected;
    }
  }

  // Removes a receiver from the stack. The FixedArray will automaticlly shrink
  // to Heap::kMinJoinStackSize once the stack becomes empty.
  builtin JoinStackPop(
      context: Context, stack: FixedArray, receiver: Object): Object {
    let len: intptr = stack.length_intptr;
    try {
      for (let i: intptr = 0; i < len; i++) {
        let el: Object = stack[i];
        if (el == receiver) goto RemoveAndShrink(i);
        if (el == Hole) return Undefined;
      }
      unreachable;
    }
    label RemoveAndShrink(i: intptr) {
      stack[i] = Hole;
      if (i == 0 && len > kMinJoinStackSize) {
        // TODO(pwong): Should be passing AllocationFlags, torque compiler error
        let newStack: FixedArray =
            AllocateFixedArray(PACKED_ELEMENTS, IntPtrConstant(kMinJoinStackSize));
        assert(kMinJoinStackSize == from_constexpr<int32>(2));
        newStack[0] = Hole;
        newStack[1] = Hole;
        SetJoinStack(newStack);
      }
    }
    return Undefined;
  }

  macro JoinStackPop_Inline(context: Context, receiver: Object) {
    let stack: FixedArray = LoadJoinStack();
    let len: intptr = stack.length_intptr;
    assert(len >= kMinJoinStackSize);

    // Fast path the common non-nested join call case.
    if (stack[0] == receiver && len == kMinJoinStackSize) {
      stack[0] = Hole;
    } else {
      JoinStackPop(context, stack, receiver);
    }
  }

  macro CycleProtectedArrayJoin<ToStringStrategy: type>(
      context: Context, receiver: JSReceiver, sepObj: Object): Object {
    // 1. Let O be ? ToObject(this value).
    // 2. Let len be ? ToLength(? Get(O, "length")).
    let len: Number = GetPropertyLength(context, receiver);

    let sep: String =
      // 3. If separator is undefined, let sep be the single-element String ",".
      sepObj == Undefined ? from_constexpr<String>(',')
      // 4. Else, let sep be ? ToString(separator).
                          : ToString_Inline(context, sepObj);
    try {
      JoinStackPush_Inline(context, receiver) otherwise CycleDetected;
      let result: Object = EnsureNotException(
        ArrayJoin<ToStringStrategy>(context, receiver, len, sep)
      ) otherwise IfException;
      JoinStackPop_Inline(context, receiver);
      return result;
    }
    label CycleDetected { return EmptyString; }
    label IfException(e: Object) {
      JoinStackPop_Inline(context, receiver);
      ReThrowError(context, e);
    }
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.join
  javascript builtin ArrayPrototypeJoin(
      context: Context, receiver: Object, sepObj: Object): Object {
    return CycleProtectedArrayJoin<UseToString>(
      context, ToObject(context, receiver), sepObj);
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.toLocaleString
  javascript builtin ArrayPrototypeToLocaleString(
      context: Context, receiver: Object, ...arguments): Object {
    return CycleProtectedArrayJoin<UseToLocaleString>(
      context, ToObject(context, receiver), ',');
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.toString
  javascript builtin ArrayPrototypeToString(
      context: Context, receiver: Object, ...arguments): Object {
    // 1. Let array be ? ToObject(this value).
    let array: JSReceiver = ToObject(context, receiver);

    // 2. Let func be ? Get(array, "join").
    let prop: Object = GetProperty(context, array, 'join');

    try {
      // 3. If IsCallable(func) is false, let func be the intrinsic function
      //    %ObjProto_toString%.
      let func: Callable = cast<Callable>(prop) otherwise NotCallable;

      // 4. Return ? Call(func, array).
      return Call(context, func, array);
    }
    label NotCallable {
      return ObjectToString(context, array);
    }
  }
}
