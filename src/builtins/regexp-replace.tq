// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include 'src/builtins/builtins-regexp-gen.h'

namespace regexp_replace {

  extern builtin
  StringIndexOf(implicit context: Context)(String, String, Smi): Smi;
  extern builtin
  SubString(implicit context: Context)(String, Smi, Smi): String;

  extern transitioning runtime
  RegExpReplaceRT(Context, JSReceiver, String, Object): String;

  // TODO(pwong): consider supporting special keyword replacement `$`.
  // extern macro StringBuiltinsAssembler::GetSubstitution(
  //   implicit context: Context)(String, Smi, Smi, String): String;

  // Fast
  extern macro
  RegExpBuiltinsAssembler::AdvanceStringIndex(String, Smi, bool): Smi;
  // Slow
  extern macro
  RegExpBuiltinsAssembler::AdvanceStringIndex(String, Number, bool): Number;

  // TODO(pwong): Consider optimizing to pass `collectCaptures: bool` to collect
  // capture start/end indices or not.
  // TODO(pwong): Create a method that takes a FastJSRegExp and one that
  // doesn't.  Both won't need to the isFast: constexpr bool. This will remove
  // the need for IsFastRegExpType.
  extern macro
  RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
      implicit context: Context)(JSReceiver, String, constexpr bool):
      RegExpMatchInfo labels IfDidNotMatch;

  macro IsFastRegExpType<T: type>(): constexpr bool {
    return false;
  }
  IsFastRegExpType<FastJSRegExp>(): constexpr bool {
    return true;
  }

  macro RegExpPrototypeExecBodyWithoutResult<T: type>(
      implicit context: Context)(regex: T, subject: String):
      RegExpMatchInfo labels IfDidNotMatch {
    return RegExpPrototypeExecBodyWithoutResult(
        regex, subject, IsFastRegExpType<T>())
        otherwise IfDidNotMatch;
  }

  macro SubStringInline(implicit context: Context)(
      string: String, start: Smi, end: Smi): String {
    return start < end ? SubString(string, start, end) : kEmptyString;
  }

  type OnMatchFn = builtin(
      Context, Object, String, Object, RegExpMatchInfo, Smi, Smi,
      Smi) => Object;
  builtin OnMatchSimpleStringReplace(
      context: Context, acc: Object, subject: String, replace: Object,
      match: RegExpMatchInfo, matchStart: Smi, matchEnd: Smi,
      lastMatchEnd: Smi): Object {
    unreachable;
  }
  macro OnMatchSimpleStringReplaceInline(implicit context: Context)(
      acc: Object, subject: String, replace: Object, matchStart: Smi,
      lastMatchEnd: Smi): Object {
    let result: String = UnsafeCast<String>(acc);
    if (lastMatchEnd != matchStart) {
      result += SubString(subject, lastMatchEnd, matchStart);
    }

    const replaceString = UnsafeCast<String>(replace);
    assert(replaceString == kEmptyString || replaceString.length_uint32 != 0);
    return replaceString == kEmptyString ? result : result + replaceString;
  }

  // TODO(pwong): Support FixedTypedArrays.
  const kLengthIndex: constexpr int31 = 0;
  const kFirstElementIndex: constexpr int31 = 1;

  // TODO(pwong): Figure out how to use the growable-fixed-array instead of
  // dupe-ing it here.
  // TODO(pwong): Compare with a rope structure.
  struct GrowableFixedArray {
    Push(obj: Tagged) {
      assert(this.length <= this.capacity);
      if (++this.length >= this.capacity) {
        const kStart: constexpr int31 = 0;
        const prevCapacity: intptr = this.capacity;

        // Growth rate is analog to JSObject::NewElementsCapacity:
        // new_capacity = (current_capacity + (current_capacity >> 1)) + 16.
        this.capacity = this.capacity + (this.capacity >> 1) + 16;
        this.array = ExtractFixedArray(
            this.array, kStart, prevCapacity, this.capacity, kFixedArrays);
      }

      this.array.objects[kLengthIndex] = Convert<Smi>(this.length);
      this.array.objects[this.length] = obj;
    }
    array: FixedArray;
    capacity: intptr;
    length: intptr;
  }

  macro NewGrowableFixedArray(implicit context: Context)(array: FixedArray):
      GrowableFixedArray {
    if (array == kEmptyFixedArray) {
      return GrowableFixedArray{array, capacity: 0, length: 0};
    } else {
      return GrowableFixedArray{
        array,
        capacity: array.length_intptr,
        length: Convert<intptr>(UnsafeCast<Smi>(array.objects[kLengthIndex]))
      };
    }
  }

  struct GrowableFixedArrayIterator {
    Next(): Object labels NoMore {
      if (this.i > this.length) goto NoMore;
      return this.array.objects[this.i++];
    }
    NextTagged(): Tagged labels NoMore {
      return this.Next() otherwise NoMore;
    }
    i: intptr;
    const array: FixedArray;
    const length: intptr;
  }
  macro NewGrowableFixedArrayIterator(implicit context: Context)(
      array: FixedArray): GrowableFixedArrayIterator {
    const length: intptr = array == kEmptyFixedArray ?
        0 :
        Convert<intptr>(UnsafeCast<Smi>(array.objects[kLengthIndex]));
    return GrowableFixedArrayIterator{i: kFirstElementIndex, array, length};
  }

  class NoCaptureMatchInfo {
    unmatched: String;
    matched: String;
    matchStart: Smi;
  }

  builtin OnMatchCallableNoCaptures(
      context: Context, acc: Object, subject: String, replace: Object,
      match: RegExpMatchInfo, matchStart: Smi, matchEnd: Smi,
      lastMatchEnd: Smi): Object {
    // TODO(pwong): Add RegExpResultsCache::Lookup() (see SearchRegExpMultiple)
    // TODO(pwong): Add RegExpResultsCache::Enter() (see SearchRegExpMultiple)
    const matched: String = SubStringInline(subject, matchStart, matchEnd);
    const unmatched: String =
        SubStringInline(subject, lastMatchEnd, matchStart);
    const info: Tagged = new NoCaptureMatchInfo{unmatched, matched, matchStart};
    let gfa: GrowableFixedArray =
        NewGrowableFixedArray(UnsafeCast<FixedArray>(acc));
    gfa.Push(info);
    return gfa.array;
  }

  builtin OnMatchCallableWithCaptures(
      context: Context, acc: Object, subject: String, replace: Object,
      match: RegExpMatchInfo, matchStart: Smi, matchEnd: Smi,
      lastMatchEnd: Smi): Object {
    // TODO(pwong): Can we use CaptureCount? This would avoid NumberOfCaptures
    // lookup.
    const nofCaptured: intptr = Convert<intptr>(match.NumberOfCaptures()) >> 1;

    // TODO(pwong): Surely there's a way to express this as an internal class...
    //   class CaptureMatchInfo {
    //     const nofCaptures: Smi;
    //     const strings[length]: String;
    //     const lastMatchEndIndex: Smi;
    //     namedCapturGroup: Object;
    //   }

    // Aguments for callable:
    // [0...n] - Captured Strings
    // [n]  - Matched Start Index
    // [n+1]  - Last Matched End Index
    // [n+2]  - Named Captures
    const length: intptr = 3 + nofCaptured;
    const callableArgs: FixedArray =
        AllocateFixedArrayWithUndefined(length, kNone);

    // [0..n] - Captured Strings
    let i: intptr = 0;
    while (i < nofCaptured) {
      const captureStart: Smi = match.GetStartOfCapture(i);
      const captureEnd: Smi = match.GetEndOfCapture(i);
      // -1 indicates the capture group did not match anything.
      if (captureStart != -1) {
        callableArgs.objects[i] =
            SubStringInline(subject, captureStart, captureEnd);
      }
      i++;
    }
    // [n] - Matched Start Index
    callableArgs.objects[i++] = matchStart;
    // [n+1]  - Unmatched String
    callableArgs.objects[i++] = lastMatchEnd;

    let gfa: GrowableFixedArray =
        NewGrowableFixedArray(UnsafeCast<FixedArray>(acc));
    gfa.Push(callableArgs);
    return gfa.array;
  }

  macro AdvanceLastIndex<T: type>(implicit context:
                                       Context)(rx: T, string: String) {
    // TODO(pwong): Rewrite external macro AdvanceStringIndex to torque.
    // - Take a string length
    // - For FastJSRegExp, use Smi arithmetic (avoid NumberInc)
    // - Test for unicode FIRST. Currently, unicode is checked AFTER adding 1 to
    // lastIndex, which if unicode is false the addition is thrown away.
    rx.lastIndex = AdvanceStringIndex(string, rx.lastIndex, rx.unicode);
  }

  type OnFinalizeFn = builtin(Context, Object, JSRegExp, String, Object) =>
      String;
  builtin OnFinalizeSimpleStringReplace(
      context: Context, acc: Object, regexp: JSRegExp, subject: String,
      replacer: Object): String {
    unreachable;
  }
  transitioning builtin OnFinalizeCallableNoCaptures(
      context: Context, acc: Object, regexp: JSRegExp, subject: String,
      replacer: Object): String {
    const replaceFn: Callable = UnsafeCast<Callable>(replacer);
    let iter = NewGrowableFixedArrayIterator(UnsafeCast<FixedArray>(acc));
    let result: String = kEmptyString;
    while (true) {
      const info =
          %RawDownCast<NoCaptureMatchInfo>(iter.NextTagged() otherwise break);

      // Append unmatched string
      // TODO(pwong): Compare performance of creating unmatched here (onMatch
      // stores lastMatchEnd) vs in OnMatch. Benefits...
      // - Skip write barrier
      // - Just-in-time allocation of string allows previous ones to be
      // collected
      const unmatched = info.unmatched;
      if (unmatched != kEmptyString) result += unmatched;

      // TODO(pwong): Compare performance of creating matched here (onMatch
      // stores matchEnd) vs in OnMatch.
      // - Skip write barrier
      // - Just-in-time allocation of string allows previous ones to be
      // collected
      const replacementObj: Object = Call(
          context, replaceFn, Undefined, info.matched, info.matchStart,
          subject);
      // TODO(pwong): Will making a version of ToString_Inline that goto IfEmpty
      // help perf?
      const replacement: String = ToString_Inline(context, replacementObj);
      if (replacement != kEmptyString) result += replacement;
    }
    return result;
  }

  macro CreateCaptureNameGroup(implicit context: Context)(
      captureNames: FixedArray, els: FixedArray): JSObject {
    assert(captureNames != kEmptyFixedArray);
    const namesLength: intptr = captureNames.length_intptr;
    const nofProperties: intptr = namesLength >> 1;
    const properties: NameDictionary = AllocateNameDictionary(nofProperties);
    for (let i: intptr = 0; i < namesLength;) {
      const name: String = UnsafeCast<String>(captureNames.objects[i++]);
      const index: Smi = UnsafeCast<Smi>(captureNames.objects[i++]);
      const capture: Object = els.objects[index];
      Add(properties, name, capture) otherwise unreachable;
    }
    return AllocateJSObjectFromMap(
        GetSlowObjectWithNullPrototypeMap(), properties);
  }

  transitioning builtin OnFinalizeCallableWithCaptures(
      context: Context, acc: Object, regexp: JSRegExp, subject: String,
      replacer: Object): String {
    const replaceFn: Callable = UnsafeCast<Callable>(replacer);
    const captureCount: intptr = Convert<intptr>(regexp.CaptureCount());
    const captureNames: FixedArray = regexp.CaptureNameMap();
    // [0...n] - Captured Strings
    // [n]     - Matched Start Index
    // [n+1]   - Last Matched End Index
    // [n+2]   - Named Captures
    const elsLength: intptr = 1 + 3 + captureCount;
    const argsLength = Convert<Smi>(
        captureNames == kEmptyFixedArray ? elsLength - 1 : elsLength);
    const argsMap: Map = GetFastPackedElementsJSArrayMap();
    let iter = NewGrowableFixedArrayIterator(UnsafeCast<FixedArray>(acc));
    let result: String = kEmptyString;
    while (true) {
      const els = UnsafeCast<FixedArray>(iter.Next() otherwise break);
      assert(elsLength == els.length_intptr);
      assert(argsLength <= els.length);

      // Append unmatched string
      const lastMatchEnd = UnsafeCast<Smi>(els.objects[elsLength - 2]);
      const matchStart = UnsafeCast<Smi>(els.objects[elsLength - 3]);
      // TODO(pwong): Factor out ConcatSubString(acc, subStringSource, start,
      // end);
      if (lastMatchEnd < matchStart) {
        result += SubString(subject, lastMatchEnd, matchStart);
      }

      // Replace the last entry with the subject
      els.objects[elsLength - 2] = subject;

      // TODO(pwong): vvv Find the spec text's name for this object.
      // Create Named Captures Group object
      if (captureNames != kEmptyFixedArray) deferred {
          els.objects[elsLength - 1] =
              CreateCaptureNameGroup(captureNames, els);
        }

      const args = new JSArray{
        map: argsMap,
        properties_or_hash: kEmptyFixedArray,
        elements: els,
        length: argsLength
      };
      const replacementObj: Object = Call(
          context, GetReflectApply(), Undefined, replaceFn, Undefined, args);
      const replacement: String = ToString_Inline(context, replacementObj);
      if (replacement != kEmptyString) result += replacement;
    }
    return result;
  }

  struct ReplaceStrategy {
    Match(implicit context: Context)(
        acc: Object, subject: String, replacer: Object, match: RegExpMatchInfo,
        matchStart: Smi, matchEnd: Smi, lastMatchEnd: Smi): Object {
      const onMatchFn: OnMatchFn = this.onMatchFn;
      if (onMatchFn == OnMatchSimpleStringReplace) {
        return OnMatchSimpleStringReplaceInline(
            acc, subject, replacer, matchStart, lastMatchEnd);
      } else {
        return onMatchFn(
            context, acc, subject, replacer, match, matchStart, matchEnd,
            lastMatchEnd);
      }
    }
    Finalize(implicit context: Context)(
        acc: Object, regexp: JSRegExp, subject: String,
        replacer: Object): String {
      const onFinalizeFn: OnFinalizeFn = this.onFinalizeFn;
      return onFinalizeFn == OnFinalizeSimpleStringReplace ?
          UnsafeCast<String>(acc) :
          onFinalizeFn(context, acc, regexp, subject, replacer);
    }
    const initialAccumulatorValue: Object;
    const onMatchFn: OnMatchFn;
    const onFinalizeFn: OnFinalizeFn;
  }

  macro Process<T: type>(implicit context: Context)(
      rx: T, subject: String, replacer: Object,
      strategy: ReplaceStrategy): String {
    let lastMatchEnd: Smi = 0;
    let acc: Object = strategy.initialAccumulatorValue;
    let hasMatches: bool = false;
    let regexp: T = rx;
    const stableRegexp: JSRegExp = regexp;
    const global: bool = regexp.global;
    // TODO(pwong): Reduce cost of loading global and unicde. Load flags once
    // and bit manipulate.
    if (global) regexp.lastIndex = 0;

    while (true) {
      const match: RegExpMatchInfo =
          RegExpPrototypeExecBodyWithoutResult(regexp, subject) otherwise break;
      hasMatches = true;
      const matchStart: Smi = match.GetStartOfCapture(0);
      const matchEnd: Smi = match.GetEndOfCapture(0);
      acc = strategy.Match(
          acc, subject, replacer, match, matchStart, matchEnd, lastMatchEnd);
      regexp = %RawDownCast<T>(stableRegexp);
      lastMatchEnd = matchEnd;

      // Non-global case ends here after the first replacement.
      if (!global) break;

      // If match is the empty string, we have to increment lastIndex.
      if (lastMatchEnd == matchStart) AdvanceLastIndex(regexp, subject);
    }
    if (!hasMatches) return subject;

    const result: String =
        strategy.Finalize(acc, stableRegexp, subject, replacer);
    const subjectLength: Smi = subject.length_smi;
    if (lastMatchEnd == subjectLength) return result;
    return result + SubStringInline(subject, lastMatchEnd, subjectLength);
  }

  macro NewReplaceStrategy(implicit context: Context)(regexp: JSRegExp):
      ReplaceStrategy {
    // The fast path is reached only if {receiver} is an unmodified JSRegExp
    // instance, {replace_value} is non-callable, and ToString({replace_value})
    // does not contain '$', i.e. we're doing a simple string replacement.
    return ReplaceStrategy{
      initialAccumulatorValue: kEmptyString,
      onMatchFn: OnMatchSimpleStringReplace,
      onFinalizeFn: OnFinalizeSimpleStringReplace
    };
  }

  macro NewReplaceStrategyForCallable(implicit context: Context)(
      regexp: JSRegExp): ReplaceStrategy {
    const captureCount: Smi = regexp.CaptureCount();
    if (captureCount == 0) {
      return ReplaceStrategy{
        initialAccumulatorValue: kEmptyFixedArray,
        onMatchFn: OnMatchCallableNoCaptures,
        onFinalizeFn: OnFinalizeCallableNoCaptures
      };
    }
    return ReplaceStrategy{
      initialAccumulatorValue: kEmptyFixedArray,
      onMatchFn: OnMatchCallableWithCaptures,
      onFinalizeFn: OnFinalizeCallableWithCaptures
    };
  }

  macro CanonicalizeEmptyString(s: String): String {
    return s.length_uint32 == 0 ? kEmptyString : s;
  }

  transitioning builtin RegExpReplace(implicit context: Context)(
      regexp: JSRegExp, string: String, replaceValue: Object): String {
    // TODO(pwong): Remove assert when all callers (StringPrototypeReplace) are
    // from Torque.
    assert(Is<FastJSRegExp>(regexp));

    // 2. Is {replace_value} callable?
    let strategy: ReplaceStrategy;
    let replacer: Object;
    typeswitch (replaceValue) {
      case (replaceFn: Callable): {
        replacer = replaceFn;
        strategy = NewReplaceStrategyForCallable(regexp);
      }
      case (Object): {
        const replaceString: String = replacer =
            CanonicalizeEmptyString(ToString_Inline(context, replaceValue));
        // ToString(replaceValue) could potentially change the shape of the
        // RegExp object. Recheck that we are still on the fast path and bail
        // to runtime otherwise.
        if (StringIndexOf(
                replaceString, SingleCharacterStringConstant('$'), 0) != -1)
          deferred {
            return RegExpReplaceRT(context, regexp, string, replaceString);
          }
        strategy = NewReplaceStrategy(regexp);
      }
    }

    try {
      const fastRegexp = Cast<FastJSRegExp>(regexp) otherwise IfSlow;
      return Process(fastRegexp, string, replacer, strategy);
    }
    label IfSlow deferred {
      return Process(regexp, string, replacer, strategy);
    }
  }

  transitioning javascript builtin RegExpPrototypeReplace(
      context: Context, receiver: Object, ...arguments): Object {
    const methodName: constexpr string = 'RegExp.prototype.@@replace';
    const string: Object = arguments[0];
    const replaceValue: Object = arguments[1];

    // Let rx be the this value.
    // If Type(rx) is not Object, throw a TypeError exception.
    const rx = Cast<JSReceiver>(receiver)
        otherwise ThrowTypeError(kIncompatibleMethodReceiver, methodName);

    // Let S be ? ToString(string).
    const s = ToString_Inline(context, string);

    // Fast-path checks: 1. Is the {receiver} an unmodified JSRegExp instance?
    try {
      const regexp: FastJSRegExp = Cast<FastJSRegExp>(rx) otherwise Runtime;
      return RegExpReplace(regexp, s, replaceValue);
    }
    label Runtime deferred {
      // TODO(pwong): Figure out why this needed.  RegExpReplace should be able
      // to handle "slow" JSRegExp.
      return RegExpReplaceRT(context, rx, s, replaceValue);
    }
  }

}
