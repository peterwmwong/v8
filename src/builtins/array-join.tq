// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module array {
  type SparseElementsAccessor;

  macro Load<ElementsAccessor: type>(
      context: Context, elements: HeapObject, i: uintptr): Object
  labels IfHole {
    return GetProperty(context, elements, convert<Number>(i));
  }

  Load<FastHoleyObjectElements>(
      context: Context, elements: HeapObject, i: uintptr): Object
  labels IfHole {
    assert(IsFixedArraySubclass(elements));
    const fixedArray: FixedArray = unsafe_cast<FixedArray>(elements);
    const element: Object = fixedArray[i];
    if (IsTheHole(element)) goto IfHole;
    return element;
  }

  Load<FastHoleyDoubleElements>(
      context: Context, elements: HeapObject, i: uintptr): Object
  labels IfHole {
    assert(IsFixedDoubleArray(elements));
    const fixedDoubleArray: FixedDoubleArray =
        unsafe_cast<FixedDoubleArray>(elements);
    const element: float64 =
        LoadDoubleWithHoleCheck(fixedDoubleArray, i) otherwise IfHole;
    return AllocateHeapNumberWithValue(element);
  }

  type UseToString;
  type UseToLocaleString;

  macro IsUseToLocaleString<ToStringStrategy: type>(): constexpr bool;
  IsUseToLocaleString<UseToString>(): constexpr bool { return false; }
  IsUseToLocaleString<UseToLocaleString>(): constexpr bool { return true; }

  macro ConvertToLocaleString(
      context: Context, element: Object, toLocaleStringLocales: Object,
      toLocaleStringOptions: Object): never
  labels IfEmpty, IfString(String, bool) {
    if (IsNullOrUndefined(element)) goto IfEmpty;

    const prop: Object = GetProperty(context, element, 'toLocaleString');
    try {
      const callable: Callable = cast<Callable>(prop) otherwise TypeError;
      const result: Object =
          IsNullOrUndefined(toLocaleStringLocales)
            ? Call(context, callable, element)
        : IsNullOrUndefined(toLocaleStringOptions)
            ? Call(context, callable, element, toLocaleStringLocales)
        : Call(context, callable, element, toLocaleStringLocales,
               toLocaleStringOptions);
      goto IfString(ToString(context, result), true);
    }
    label TypeError {
      ThrowTypeError(context, kCalledNonCallable, prop);
    }
  }

  // Specialized ToString() for Array.p.join(), allowing optimized handling for
  // the following cases:
  //   - IfEmpty: null or undefined
  //   - IfString: converted to a string with no side-effects
  macro ConvertToString<ElementsAccessor: type>(
      context: Context, element: Object): never
  labels IfEmpty, IfString(String, bool) {
    if (TaggedIsSmi(element)) {
      goto IfString(SmiToString(unsafe_cast<Smi>(element)), false);
    }

    const elementObj: HeapObject = unsafe_cast<HeapObject>(element);
    // TODO(pwong): Use type switch
    if (IsString(elementObj)) {
      goto IfString(unsafe_cast<String>(element), false);
    } else if (IsHeapNumber(elementObj)) {
      goto IfString(HeapNumberToString(unsafe_cast<HeapNumber>(element)), false);
    } else if (IsNullOrUndefined(element)) {
      goto IfEmpty;
    } else {
      // TODO(pwong): Mark this branch as 'unlikely' for performance improvement
      // (5-10%), when Torque has the ability to mark a branch 'kDeferred'.

      // TODO(pwong): Propose Torque capability to allow similar functionality
      // to `DisallowJavascriptExecution`.
      goto IfString(ToString(context, element), true);
    }
  }

  ConvertToString<FastHoleyDoubleElements>(
      context: Context, element: Object): never
  labels IfEmpty, IfString(String, bool) {
    // TODO(pwong): Further optimize by  creating a Float64ToString helper. This
    // would avoid allocating the heap number (see
    // Load<FastHoleyDoubleElements>.
    goto IfString(HeapNumberToString(unsafe_cast<HeapNumber>(element)), false);
  }

  // Verifies the current element accessor can still be safely used
  // (see Load<ElementsAccessor>). As an optimization, this is only called when
  // ToString() may have had side-effects (see
  // ConvertToString<ElementsAccessor> label IfStringWithSideEffects).
  macro CannotUseSameAccessor<ElementsAccessor: type>(
      originalMap: Object, originalLen: Object, receiver: JSReceiver): never
  labels Cannot, Can {
    const array: JSArray = unsafe_cast<JSArray>(receiver);
    if (originalMap != array.map) goto Cannot;
    if (originalLen != array.length) goto Cannot;
    if (IsNoElementsProtectorCellInvalid()) goto Cannot;
    goto Can;
  }

  CannotUseSameAccessor<GenericElementsAccessor>(
      originalMap: Object, originalLen: Object, receiver: JSReceiver): never
  labels Cannot, Can {
    // The GenericElementsAccessor element accessor is designed to handle all
    // cases when loading an element from a receiver (see
    // Load<GenericElementsAccessor>).
    goto Can;
  }

  CannotUseSameAccessor<SparseElementsAccessor>(
      originalMap: Object, originalLen: Object, receiver: JSReceiver): never
  labels Cannot, Can {
    // To simplify the specialization of dictionary elements, we simply bailout
    // if any dictionary element called JS code during `ToString`.
    // TODO(pwong): This useless identity check is to fake out Torque so it can
    // generate the Can (else branch) in ArrayJoinImpl.
    if (receiver == receiver) goto Cannot;
    goto Can;
  }

  struct KeyIterator {
    done: bool;
    k: uintptr;
    elements: HeapObject;
    sparseK: uintptr;
    sparseIndices: FixedArrayBase;
  }

  macro KeyIteratorInit<ElementsAccessor: type>(
      context: Context, receiver: JSReceiver, len: uintptr,
      initialK: uintptr): KeyIterator {
    const array: JSArray = unsafe_cast<JSArray>(receiver);
    const elements: FixedArrayBase = array.elements;
    // Fast path is built on the assumption that the receiver's length does not
    // change from the beginning of the call to Array.p.join().
    // TODO(pwong): why does this assertion fail? vvv
    assert(elements.length_intptr == Signed(len));
    const done: bool = len == 0;
    return KeyIterator{done, initialK, elements, 0, kEmptyFixedArray};
  }

  KeyIteratorInit<GenericElementsAccessor>(
      context: Context, receiver: JSReceiver, len: uintptr,
      initialK: uintptr): KeyIterator {
    let done: bool = len == 0;
    if (!done) done = initialK >= len;
    return KeyIterator{done, initialK, receiver, 0, kEmptyFixedArray};
  }

  KeyIteratorInit<SparseElementsAccessor>(
      context: Context, receiver: JSReceiver, len: uintptr,
      initialK: uintptr): KeyIterator {
    const array: JSArray = unsafe_cast<JSArray>(receiver);
    // Only the GenericElementsAccessor specialization (handles continuation)
    // is a non-zero `initialK` possible.
    assert(initialK == 0);
    const sparseIndices: FixedArray =
      GetSortedArrayKeys(context, array, convert<Number>(len));
    const done: bool = IsEmptyFixedArray(sparseIndices);
    const k: uintptr = done ? from_constexpr<uintptr>(0)
      : convert<uintptr>(unsafe_cast<Number>(sparseIndices[0]));

    return KeyIterator{done, k, array, 0, sparseIndices};
  }

  macro KeyIteratorNext<ElementsAccessor: type>(
      len: uintptr, state: KeyIterator): KeyIterator {
    const k: uintptr = state.k + 1;
    const done: bool = k >= len;
    return KeyIterator{done, k, state.elements, 0, state.sparseIndices};
  }

  KeyIteratorNext<SparseElementsAccessor>(
      len: uintptr, state: KeyIterator): KeyIterator {
    const sparseK: uintptr = state.sparseK + 1;
    assert(IsFixedArraySubclass(state.sparseIndices));
    const sparseIndices: FixedArray =
      unsafe_cast<FixedArray>(state.sparseIndices);
    assert(sparseIndices.length_intptr >= 0);
    const done: bool = sparseK >= Unsigned(sparseIndices.length_intptr);
    const k: uintptr = done ? state.k
      : convert<uintptr>(unsafe_cast<Number>(sparseIndices[sparseK]));
    return KeyIterator{done, k, state.elements, sparseK, sparseIndices};
  }

  macro EstimateBufferSize<ElementsAccessor: type>(state: KeyIterator,
                                                   len: uintptr): uintptr {
    return len;
  }

  EstimateBufferSize<SparseElementsAccessor>(state: KeyIterator,
                                             len: uintptr): uintptr {
    assert(IsFixedArraySubclass(state.sparseIndices));
    const sparseIndices: FixedArray =
      unsafe_cast<FixedArray>(state.sparseIndices);
    return (Unsigned(sparseIndices.length_intptr) << 1) + 1;
  }

  // TODO(pwong): Add more documentation.
  //   1) Add Translation Example
  //      - Input JS Array: [,'hello',,'world',]
  //      - Output:         [1,'hello',1,'world',1]
  struct StringGapBuffer {
    // Fixed array holding elements that are either:
    //   1) String result of `ToString(element)`
    //   2) Smi (> 1) representing the number of consecutive seperators
    // `BufferJoin()` iterates over and writes these entries into a flatten
    // string.
    fixedArray: FixedArrayBase;

    // Index to insert a new entry into `fixedArray`.
    index: uintptr;

    // Last entry's associated `k` (JS Receiver's key). This is used to
    // calculate the gap between entries.
    lastK: uintptr;

    // Running total of the resulting string length when `BufferJoin()` is
    // called.
    // TODO(pwong): make this a intptr
    stringLen: uintptr;

    // `true` if all strings in the buffer are one-byte, otherwise `false`.
    isOneByte: bool;

    // Store gap threshold. To reduce size needed for `fixedArray`, we only
    // include the gap if it's greater than one.  The only exception is when
    // the gap is at the start of the receiver.
    gapThreshold: uintptr;
  }

  macro BufferInit(len: uintptr): StringGapBuffer {
    // TODO(pwong): Welp, vvv No longer sound! String max > FixedArray max!!!
    // Implement buffer full algo in ArrayJoinImpl:
    //
    //    if (buffer.isFull) {
    //      r = BufferJoin();
    //      buffer = BufferInit();
    //    }
    //
    // TODO(pwong): Write test
    // TODO(pwong): Update vvv comment!
    // Note about the capped length: Eventhough the receiver's length may exceed
    // `FixedArray::kMaxLength`, because this only holds the strings (and gaps)
    // to be rendered to a string, this is sound as long as `String::kMaxLength`
    // is less than `FixedArray::kMaxLength`.
    const len: uintptr = len < kFixedArrayMaxLength ? len
      : convert<uintptr>(kFixedArrayMaxLength);
    const fixedArray: FixedArrayBase = len == 0 ? kEmptyFixedArray
      : AllocateFixedArrayWithHoles(PACKED_ELEMENTS, Signed(len), kNone);
    // TODO(pwong): index, lastK, stringLen need to be passed in for
    // continuation support.
    return StringGapBuffer{fixedArray, 0, 0, 0, true, 0};
  }

  macro BufferAdd(context: Context, buf: StringGapBuffer, str: String,
                  k: uintptr, sepLen: uintptr): StringGapBuffer {
    // TODO(pwong): if constexpr (CanHaveGaps<ElementsAccessor>())
    // - FastPackedSmiElementAccessor
    // - FastPackedDoubleElementsAccessor
    const gap: uintptr = k - buf.lastK;
    assert(IsFixedArraySubclass(buf.fixedArray));
    const fixedArray: FixedArray = unsafe_cast<FixedArray>(buf.fixedArray);
    assert(str.length >= 0);
    let stringLen: uintptr = Unsigned(str.length) + buf.stringLen;
    let index: uintptr = buf.index;
    if (sepLen > 0) {
      const gapLen: uintptr = gap * sepLen;
      stringLen = stringLen + gapLen;
      if (gap > buf.gapThreshold) {
        assert(Signed(index) < fixedArray.length_intptr);
        StoreFixedArrayElement(fixedArray, Signed(index++), convert<Smi>(Signed(gap)),
                              SKIP_WRITE_BARRIER);
      }
    }
    assert(Signed(index) < fixedArray.length_intptr);
    StoreFixedArrayElement(fixedArray, Signed(index++), str, SKIP_WRITE_BARRIER);
    const isOneByte: bool =
      IsOneByteStringInstanceType(str.instanceType) & buf.isOneByte;
    return StringGapBuffer{fixedArray, index, k, stringLen, isOneByte, 1};
  }

  extern macro CallWriteFixedArrayToFlatSeq(FixedArray, uintptr, String,
                                            String): String;

  macro BufferFinalize(context: Context, buf: StringGapBuffer, len: uintptr,
                       sepLen: uintptr): StringGapBuffer {
    assert(IsFixedArraySubclass(buf.fixedArray));
    const fixedArray: FixedArray = unsafe_cast<FixedArray>(buf.fixedArray);
    const gap: uintptr = len - buf.lastK - 1;
    let index: uintptr = buf.index;
    let stringLen: uintptr = buf.stringLen;
    if (gap > 0) {
      stringLen = stringLen + sepLen * gap;
      StoreFixedArrayElement(fixedArray, Signed(index++), convert<Smi>(Signed(gap)),
                             SKIP_WRITE_BARRIER);
    }
    return StringGapBuffer{
      fixedArray, index, buf.lastK, stringLen, buf.isOneByte, 1};
  }

  macro BufferJoin(context: Context, initialString: String,
                   buf: StringGapBuffer, sep: String): String {
    const stringLen: intptr = initialString.length + Signed(buf.stringLen);
    if (stringLen > kStringMaxLength) {
      ThrowTypeError(context, kInvalidStringLength);
    } else if (stringLen == 0) {
      return EmptyString;
    }

    assert(IsValidPositiveSmi(stringLen));
    const stringLenSmi: Smi = convert<Smi>(stringLen);
    assert(IsFixedArraySubclass(buf.fixedArray));
    const fixedArray: FixedArray = unsafe_cast<FixedArray>(buf.fixedArray);
    const isOneByte: bool =
      buf.isOneByte
      & IsOneByteStringInstanceType(sep.instanceType)
      & IsOneByteStringInstanceType(initialString.instanceType);
    const r: String =
      isOneByte
        ? AllocateSeqOneByteString(context, stringLenSmi)
        : AllocateSeqTwoByteString(context, stringLenSmi);
    return CallWriteFixedArrayToFlatSeq(fixedArray, buf.index, sep, r);
  }

  macro LoadStringElement<ElementsAccessor: type, ToStringStrategy: type>(
      context: Context, elements: HeapObject, k: uintptr,
      toLocaleStringLocales: Object, toLocaleStringOptions: Object): never
  labels Skip, IfString(String, bool) {
    // b. Let element be ? Get(O, ! ToString(k)).
    const element: Object = Load<ElementsAccessor>(context, elements, k)
    otherwise Skip;

    // c. If element is undefined or null, let next be the empty String;
    //    otherwise, let next be ? ToString(element).
    if constexpr (IsUseToLocaleString<ToStringStrategy>()) {
      ConvertToLocaleString(
        context, element, toLocaleStringLocales, toLocaleStringOptions)
      otherwise Skip, IfString;
    } else {
      ConvertToString<ElementsAccessor>(context, element)
      otherwise Skip, IfString;
    }
  }

  macro ArrayJoinImpl<ElementsAccessor: type, ToStringStrategy: type>(
      context: Context, receiver: JSReceiver, len: uintptr, sep: String,
      initialString: String, initialIndex: uintptr, initialLen: Number,
      initialMap: Object, toLocaleStringLocales: Object,
      toLocaleStringOptions: Object): String
  labels Continuation(uintptr, String) {
    assert(sep.length >= 0);
    const sepLen: uintptr = Unsigned(sep.length);

    // 5. Let R be the empty String.
    // 6. Let k be 0.
    let state: KeyIterator =
      KeyIteratorInit<ElementsAccessor>(context, receiver, len, initialIndex);

    const bufferLen: uintptr = EstimateBufferSize<ElementsAccessor>(state, len);
    let stringGapBuffer: StringGapBuffer = BufferInit(bufferLen);

    // 7. Repeat, while k < len
    // while(from_constexpr<bool>(true)) {
    while(!state.done) {
      const k: uintptr = state.k;
      try {
        LoadStringElement<ElementsAccessor, ToStringStrategy>(
          context, state.elements, k, toLocaleStringLocales,
          toLocaleStringOptions)
        otherwise Skip, IfString;
      }
      label IfString(next: String, mayHaveCalledJS: bool) {
        // d. Set R to the string-concatenation of R and next.
        stringGapBuffer = BufferAdd(context, stringGapBuffer, next, k, sepLen);

        if (mayHaveCalledJS) {
          if (CannotUseSameAccessor<ElementsAccessor>(initialMap, initialLen,
                                                      receiver)) {
            // const r: String = "yolo";
            const r: String = BufferJoin(context, initialString, stringGapBuffer, sep);
            goto Continuation(k + 1, r);
          }
        }
      }
      label Skip {}

      // e. Increment k by 1.
      state = KeyIteratorNext<ElementsAccessor>(len, state);

      // TODO(pwong): benchmark if this while(true) loop is actually worth the
      // weird looking code
      // if (state.done) {
      //   break;
      // }
    }

    stringGapBuffer = BufferFinalize(context, stringGapBuffer, len, sepLen);

    // 8. Return R.
    return BufferJoin(context, initialString, stringGapBuffer, sep);
  }

  builtin ArrayJoinContinuation<ToStringStrategy: type>(
      context: Context, receiver: JSReceiver, sep: String, len: Number,
      initialString: String, initialIndex: Number,
      toLocaleStringLocales: Object, toLocaleStringOptions: Object): Object {
    try {
      const initialIndexInt: uintptr = convert<uintptr>(initialIndex);
      const lenInt: uintptr = convert<uintptr>(len);
      return ArrayJoinImpl<GenericElementsAccessor, ToStringStrategy>(
        context, receiver, lenInt, sep, initialString, initialIndexInt, len,
        Undefined, toLocaleStringLocales, toLocaleStringOptions)
      otherwise Continuation;
    }
    label Continuation(i: uintptr, r: String) {
      // The GenericElementsAccessor element accessor is designed to handle all
      // cases and never bails out (see Load<GenericElementsAccessor>).
      unreachable;
    }
  }

  // TODO(pwong): Measure performance impact of using GetLengthProperty (array.tq)
  macro GetPropertyLength(context: Context, obj: HeapObject): Number {
    if (IsJSArray(obj)) {
      const array: JSArray = unsafe_cast<JSArray>(obj);
      return array.length;
    } else {
      const lenObj: Object = GetProperty(context, obj, LengthString);
      return ToLength_Inline(context, lenObj);
    }
  }

  macro IsSparseDictionary(context: Context, array: JSArray,
                           len: uintptr): bool {
    assert(IsNumberDictionary(array.elements));
    const elements: NumberDictionary =
      unsafe_cast<NumberDictionary>(array.elements);
    const estimated_nof: uintptr =
      convert<uintptr>(GetNumberDictionaryNumberOfElements(elements));

    // No more than 75% holes
    return estimated_nof < (len >>> 2);
  }

  builtin ArrayJoin<ToStringStrategy: type>(
      context: Context, receiver: JSReceiver, len: Number,
      sep: String, toLocaleStringLocales: Object,
      toLocaleStringOptions: Object): Object {
    try {
      const map: Map = receiver.map;

      if (IsJSArrayMap(map)) {
        assert(IsJSArray(receiver));
        const array: JSArray = unsafe_cast<JSArray>(receiver);
        const arrayLen: Object = array.length;

        if (arrayLen == len) {
          const kind: ElementsKind = map.elements_kind;
          const lenInt: uintptr = convert<uintptr>(len);

          if(IsPrototypeInitialArrayPrototype(context, map) &&
             !IsNoElementsProtectorCellInvalid()) {
            const elements: FixedArrayBase = array.elements;

            if (kind <= HOLEY_ELEMENTS) {
              return ArrayJoinImpl<FastHoleyObjectElements, ToStringStrategy>(
                context, array, lenInt, sep, EmptyString, 0, len, map,
                toLocaleStringLocales, toLocaleStringOptions)
              otherwise Continuation;
            } else if (kind <= HOLEY_DOUBLE_ELEMENTS) {
              return ArrayJoinImpl<FastHoleyDoubleElements, ToStringStrategy>(
                context, array, lenInt, sep, EmptyString, 0, len, map,
                toLocaleStringLocales, toLocaleStringOptions)
              otherwise Continuation;
            }
          }
          if (kind == DICTIONARY_ELEMENTS &&
              HasComplexElements(context, array) == False &&
              IsSparseDictionary(context, array, lenInt)) {
            return ArrayJoinImpl<SparseElementsAccessor, ToStringStrategy>(
              context, array, lenInt, sep, EmptyString, 0, len, map,
              toLocaleStringLocales, toLocaleStringOptions)
            otherwise Continuation;
          }
        }
      }
      goto Continuation(0, EmptyString);
    }
    label Continuation(i: uintptr, r: String) {
      return ArrayJoinContinuation<ToStringStrategy>(
        context, receiver, sep, len, r, convert<Number>(i),
        toLocaleStringLocales, toLocaleStringOptions);
    }
  }

  // The Join Stack detects cyclical calls to Array.p.join.  This FixedArray
  // holds a stack of JSArrays that are receivers to the current call
  // to Array.p.join. The Array.p.join builtin is responsible for calling
  // JoinStackPush and JoinStackPop when visiting and leaving a JSArray,
  // respectively.
  const kMinJoinStackSize: constexpr int32 generates
    'JSArray::kMinJoinStackSize';
  const kArrayJoinStackRootIndex: constexpr RootListIndex generates
    'Heap::kArrayJoinStackRootIndex';
  macro LoadJoinStack(): FixedArray {
    return unsafe_cast<FixedArray>(LoadRoot(kArrayJoinStackRootIndex));
  }
  macro SetJoinStack(stack: FixedArray): void {
    StoreRoot(kArrayJoinStackRootIndex, stack);
  }

  // Adds a receiver to the stack. The FixedArray will automaticlly grow to
  // accomadate the receiver. If the receiver already exists on the stack,
  // this indicates a cyclical call and False is returned.
  builtin JoinStackPush(
      context: Context, stack: FixedArray, receiver: Object): Boolean {
    const len: intptr = stack.length_intptr;
    for (let i: intptr = 0; i < len; i++) {
      const previouslyVisited: Object = stack[i];

      // Add `receiver` to the first open slot
      if (previouslyVisited == Hole) {
        stack[i] = receiver;
        return True;
      }

      // Detect cycles
      if (receiver == previouslyVisited) return False;
    }

    // If no open slots were found, grow the stack and add receiver to the end.
    // Growth rate is analog to JSObject::NewElementsCapacity:
    // new_capacity = (current_capacity + (current_capacity >> 1)) + 16.
    const capacity: intptr = (len + (len >> 1)) + 16;
    const newStack: FixedArray =
      ExtractFixedArray(stack, 0, len, capacity, kFixedArrays);
    newStack[len] = receiver;
    SetJoinStack(newStack);
    return True;
  }

  macro JoinStackPush_Inline(context: Context, receiver: Object)
  labels CycleDetected {
    const stack: FixedArray = LoadJoinStack();
    assert(stack.length_intptr >= kMinJoinStackSize);

    // Fast path the common non-nested join call case.
    if (stack[0] == Hole) {
      stack[0] = receiver;
    } else if (JoinStackPush(context, stack, receiver) == False) {
      goto CycleDetected;
    }
  }

  // Removes a receiver from the stack. The FixedArray will automaticlly shrink
  // to Heap::kMinJoinStackSize once the stack becomes empty.
  builtin JoinStackPop(
      context: Context, stack: FixedArray, receiver: Object): Object {
    const len: intptr = stack.length_intptr;
    for (let i: intptr = 0; i < len; i++) {
      const element: Object = stack[i];
      if (element == receiver) {
        stack[i] = Hole;
        if (i == 0 && len > kMinJoinStackSize) {
          const newStack: FixedArray =
            AllocateFixedArray(PACKED_ELEMENTS, kMinJoinStackSize);
          assert(kMinJoinStackSize == from_constexpr<int32>(2));
          newStack[0] = Hole;
          newStack[1] = Hole;
          SetJoinStack(newStack);
        }
        return Undefined;
      } else if (element == Hole) {
        return Undefined;
      }
    }
    unreachable;
  }

  macro JoinStackPop_Inline(context: Context, receiver: Object) {
    const stack: FixedArray = LoadJoinStack();
    const len: intptr = stack.length_intptr;
    assert(len >= kMinJoinStackSize);

    // Fast path the common non-nested join call case.
    if (stack[0] == receiver && len == kMinJoinStackSize) {
      stack[0] = Hole;
    } else {
      tail JoinStackPop(context, stack, receiver);
    }
  }

  macro CycleProtectedArrayJoin<ToStringStrategy: type>(
      context: Context, receiver: JSReceiver, sepObj: Object,
      toLocaleStringLocales: Object, toLocaleStringOptions: Object): Object {
    // 1. Let O be ? ToObject(this value).
    // 2. Let len be ? ToLength(? Get(O, "length")).
    const len: Number = GetPropertyLength(context, receiver);
    const sep: String =
      // 3. If separator is undefined, let sep be the single-element String ",".
      sepObj == Undefined ? from_constexpr<String>(',')
      // 4. Else, let sep be ? ToString(separator).
                          : ToString_Inline(context, sepObj);

    try {
      // Fast paths for zero and one elements
      const zero: Object = convert<Smi>(0);
      const one: Object = convert<Smi>(1);
      if (len == zero) return EmptyString;
      if (len == one) {
        LoadStringElement<GenericElementsAccessor, ToStringStrategy>(
          context, receiver, 0, toLocaleStringLocales, toLocaleStringOptions)
        otherwise IfReturnEmpty, IfOneElement;
      }

      JoinStackPush_Inline(context, receiver) otherwise IfReturnEmpty;
      const result: Object = EnsureNotException(
        ArrayJoin<ToStringStrategy>(
          context, receiver, len, sep, toLocaleStringLocales,
          toLocaleStringOptions)
      ) otherwise IfException;
      JoinStackPop_Inline(context, receiver);
      return result;
    }
    label IfReturnEmpty { return EmptyString; }
    label IfOneElement(s: String, b: bool) { return s; }
    label IfException(e: Object) {
      JoinStackPop_Inline(context, receiver);
      ReThrowError(context, e);
    }
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.join
  javascript builtin ArrayPrototypeJoin(
      context: Context, receiver: Object, sepObj: Object): Object {
    return CycleProtectedArrayJoin<UseToString>(
      context, ToObject(context, receiver), sepObj, Undefined, Undefined);
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.toLocaleString
  javascript builtin ArrayPrototypeToLocaleString(
      context: Context, receiver: Object, ...arguments): Object {
    const toLocaleStringLocales: Object =
      arguments.length > 0 ? arguments[0] : Undefined;
    const toLocaleStringOptions: Object =
      arguments.length > 1 ? arguments[1] : Undefined;
    return CycleProtectedArrayJoin<UseToLocaleString>(
      context, ToObject(context, receiver), ',', toLocaleStringLocales,
      toLocaleStringOptions);
  }

  // https://tc39.github.io/ecma262/#sec-array.prototype.toString
  javascript builtin ArrayPrototypeToString(
      context: Context, receiver: Object, ...arguments): Object {
    // 1. Let array be ? ToObject(this value).
    const array: JSReceiver = ToObject(context, receiver);

    // 2. Let func be ? Get(array, "join").
    const prop: Object = GetProperty(context, array, 'join');

    try {
      // 3. If IsCallable(func) is false, let func be the intrinsic function
      //    %ObjProto_toString%.
      const func: Callable = cast<Callable>(prop) otherwise NotCallable;

      // 4. Return ? Call(func, array).
      return Call(context, func, array);
    }
    label NotCallable {
      tail ObjectToString(context, array);
    }
  }
}
