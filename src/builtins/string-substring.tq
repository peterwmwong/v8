// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace string {

extern macro AllocateSlicedOneByteString(uint32, String, Smi): String;
extern macro AllocateSlicedTwoByteString(uint32, String, Smi): String;
extern macro SingleCharacterStringCacheConstant(): FixedArray;
extern macro UnsafeLoadFixedArrayElement(FixedArray, intptr): Object;

extern macro StringBuiltinsAssembler::LoadChar8(RawPtr, uintptr): char8;
extern macro StringBuiltinsAssembler::StoreChar8(RawPtr, uintptr, char8): void;

const kSingleCharacterStringCache: FixedArray =
    SingleCharacterStringCacheConstant();
const kMaxOneByteCharCode:
    constexpr int31 generates 'String::kMaxOneByteCharCode';
const kSlicedStringMinLength:
    constexpr int31 generates 'SlicedString::kMinLength';

// macro StringFromSingleCharCode2(char: char8): String {
//   const charInt = Convert<intptr>(Convert<uint32>(char));
//   const maybeString =
//       UnsafeLoadFixedArrayElement(kSingleCharacterStringCache, charInt);
//   if (maybeString != Undefined) {
//     return UnsafeCast<String>(maybeString);
//   } else
//     deferred {
//       const result = AllocateNonEmptySeqOneByteString(
//           1, ConstantIterator(char));
//       kSingleCharacterStringCache.objects[charInt] = result;
//       return result;
//     }
// }

macro WriteToString<T: type, U: type>(
    src: ConstSlice<T>, srcFrom: intptr, dest: U, length: uintptr): U {
  assert(
      length > 0 && (src.length - srcFrom) >= Signed(length) &&
      dest.length_uintptr >= length);
  const srcPtr =
      src.GCUnsafeStartPointer() + torque_internal::TimesSizeOf<T>(srcFrom);
  const destSlice: ConstSlice<T> = &dest.chars;
  const destPtr = destSlice.GCUnsafeStartPointer();
  const byteLength = Unsigned(torque_internal::TimesSizeOf<T>(Signed(length)));
  let i: uintptr = 0;
  while (true) {
    StoreChar8(destPtr, i, LoadChar8(srcPtr, i));
    if (++i == byteLength) break;
  }
  return dest;
}

macro SubString(string: String, from: uintptr, to: uintptr): String {
  const length = to - from;
  assert(length <= string.length_uintptr);
  if (length == string.length_uintptr) return string;
  if (length == 0) return kEmptyString;
  try {
    StringToStringSlice(string) otherwise OneByte, TwoByte;
  } label OneByte(p: String, o: intptr, s: ConstSlice<char8>) {
    if (length == 1) deferred {
        Comment('StringFromSingleCharCode2 START');
        // const result =
        // StringFromSingleCharCode2(LoadChar8(Convert<RawPtr>(s.GCUnsafeStartPointer()),
        // from));
        const char = LoadChar8(Convert<RawPtr>(s.GCUnsafeStartPointer()), from);
        const charInt = Convert<intptr>(Convert<uint32>(char));
        const maybeString =
            UnsafeLoadFixedArrayElement(kSingleCharacterStringCache, charInt);
        if (IsUndefined(maybeString)) deferred {
            const result =
                AllocateNonEmptySeqOneByteString(1, ConstantIterator(char));
            kSingleCharacterStringCache.objects[charInt] = result;
            return result;
          }
        else {
          Comment('StringFromSingleCharCode2 END');
          return %RawDownCast<String>(maybeString);
        }
      }
    const fromInt = Convert<intptr>(from);
    if (length < kSlicedStringMinLength) {
      return WriteToString(
          s, fromInt, AllocateNonEmptySeqOneByteString(Convert<uint32>(length)),
          length);
    }
    return AllocateSlicedOneByteString(
        Convert<uint32>(length), p, SmiTag(o + fromInt));
  } label TwoByte(p: String, o: intptr, s: ConstSlice<char16>) deferred {
    Comment('TwoByte START');
    const fromInt = Convert<intptr>(from);
    if (length < kSlicedStringMinLength) {
      return WriteToString(
          s, fromInt, AllocateNonEmptySeqTwoByteString(Convert<uint32>(length)),
          length);
    }
    return AllocateSlicedTwoByteString(
        Convert<uint32>(length), p, SmiTag(o + fromInt));
  }
}

builtin SubString(implicit context: Context)(
    s: String, from: Smi, to: Smi): String {
  return SubString(
      s, Unsigned(Convert<intptr>(from)), Unsigned(Convert<intptr>(to)));
}

builtin StringSubstring(implicit context: Context)(
    s: String, from: intptr, to: intptr): String {
  return SubString(s, Unsigned(from), Unsigned(to));
}

// ES6 #sec-string.prototype.substring
transitioning javascript builtin StringPrototypeSubstring(
    js-implicit context: NativeContext, receiver: JSAny)(...arguments): String {
  // Check that {receiver} is coercible to Object and convert it to a String.
  const string: String = ToThisString(receiver, 'String.prototype.substring');
  const length: uintptr = string.length_uintptr;

  // Conversion and bounds-checks for {start}.
  const arg0 = arguments[0];
  let start: uintptr = arg0 != Undefined ? ClampToIndexRange(arg0, length) : 0;

  // Conversion and bounds-checks for {end}.
  const arg1 = arguments[1];
  let end: uintptr =
      arg1 != Undefined ? ClampToIndexRange(arg1, length) : length;
  if (end < start) {
    const tmp: uintptr = end;
    end = start;
    start = tmp;
  }
  return SubString(string, start, end);
}
}
