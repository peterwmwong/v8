// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace string {

const kFlagStringSlices: constexpr bool generates 'FLAG_string_slices';

macro OneByteStringFromSingleCharCode(charCode: char8|
                                      char16): String labels TwoByteCharCode {
  if (charCode <= kMaxOneByteCharCode) deferred {
      let result =
  &kSingleCharacterStringCache.objects[Convert<uintptr>(charCode)];
      if (*result == Undefined) {
        *result = AllocateNonEmptySeqOneByteString(
            1, ConstantIterator(%RawDownCast<char8>(charCode)));
      }
      return UnsafeCast<String>(*result);
    }
  goto TwoByteCharCode;
}

@export
macro StringFromSingleCharCode(charCode: char8|char16): String {
  return OneByteStringFromSingleCharCode(charCode)
      otherwise return AllocateNonEmptySeqTwoByteString(
      1, ConstantIterator(%RawDownCast<char16>(charCode)));
}

macro SubstringInline(string: String, from: uintptr, to: uintptr): String {
  const length = Convert<intptr>(to - from);
  assert(from <= to && length <= string.length_intptr);
  if (length == string.length_intptr) return string;
  if (length == 0) return kEmptyString;

  const slice = string.Slice(from, to);
  if constexpr (kFlagStringSlices) {
    if (slice.length >= kSlicedStringMinLength) {
      return new SlicedString{
        map: slice.isOneByte ? kSlicedOneByteStringMap : kSlicedStringMap,
        raw_hash_field: kNameEmptyHashField,
        length: Convert<int32>(slice.length),
        parent: slice.root,
        offset: Convert<Smi>(slice.rootOffset)
      };
    }
  }

  if (slice.length == 1) {
    try {
      return OneByteStringFromSingleCharCode(slice.AtIndex(0))
          otherwise TwoByteCharCode;
    } label TwoByteCharCode {}
  }

  const lengthUint32 = Convert<uint32>(Unsigned(slice.length));
  try {
    slice.Chars() otherwise OneByte, TwoByte;
  } label OneByte(s: ConstSlice<char8>) {
    return AllocateNonEmptySeqOneByteString(lengthUint32, s);
  } label TwoByte(s: ConstSlice<char16>) {
    return AllocateNonEmptySeqTwoByteString(lengthUint32, s);
  }
}

// Return a new string object which holds a substring containing the range
// [from,to[ of string.
builtin StringSubstring(implicit context: Context)(
    s: String, from: uintptr, to: uintptr): String {
  return SubstringInline(s, from, to);
}

// ES6 #sec-string.prototype.substring
transitioning javascript builtin StringPrototypeSubstring(
    js-implicit context: NativeContext, receiver: JSAny)(...arguments): String {
  // Check that {receiver} is coercible to Object and convert it to a String.
  const string: String = ToThisString(receiver, 'String.prototype.substring');
  const length: uintptr = string.length_uintptr;

  // Conversion and bounds-checks for {start}.
  const arg0 = arguments[0];
  let start: uintptr = arg0 != Undefined ? ClampToIndexRange(arg0, length) : 0;

  // Conversion and bounds-checks for {end}.
  const arg1 = arguments[1];
  let end: uintptr =
      arg1 != Undefined ? ClampToIndexRange(arg1, length) : length;
  if (end < start) {
    const tmp: uintptr = end;
    end = start;
    start = tmp;
  }
  return SubstringInline(string, start, end);
}
}
