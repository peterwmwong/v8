// Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

module array {
  // Naming convention from elements.cc. We have a similar intent but implement
  // fastpaths using generics instead of using a class hierarchy for elements
  // kinds specific implementations.
  type GenericElementsAccessor;
  type FastHoleySmiElements;
  type FastHoleyObjectElements;
  type FastHoleyDoubleElements;
  type DictionaryElements;

  macro LoadReceiverElements<ElementsAccessor: type>(receiver: Object): Object {
    assert(!TaggedIsSmi(receiver));
    assert(IsJSArray(unsafe_cast<HeapObject>(receiver)));
    let array: JSArray = unsafe_cast<JSArray>(receiver);
    return array.elements;
  }

  LoadReceiverElements<GenericElementsAccessor>(receiver: Object): Object {
    return receiver;
  }

  macro Load<ElementsAccessor: type>(
      context: Context, elementsObj: Object, index: intptr): Object
  labels IfHole, IfException(Object) {
    let elements: FixedArray = unsafe_cast<FixedArray>(elementsObj);
    let el: Object = elements[index];
    if (IsTheHole(el)) goto IfHole;
    return el;
  }

  Load<GenericElementsAccessor>(
      context: Context, elementsObj: Object, index: intptr): Object
  labels IfHole, IfException(Object) {
    let indexNumber: Number = convert<Number>(index);
    return EnsureNotException(GetProperty(context, elementsObj, indexNumber))
    otherwise IfException;
  }

  Load<FastHoleyDoubleElements>(
      context: Context, elementsObj: Object, index: intptr): Object
  labels IfHole, IfException(Object) {
    let elements: FixedDoubleArray = unsafe_cast<FixedDoubleArray>(elementsObj);
    let el: float64 = LoadDoubleWithHoleCheck(elements, index) otherwise IfHole;
    return AllocateHeapNumberWithValue(el);
  }

  Load<DictionaryElements>(
      context: Context, elementsObj: Object, index: intptr): Object
  labels IfHole, IfException(Object) {
    let elements: NumberDictionary = unsafe_cast<NumberDictionary>(elementsObj);
    return BasicLoadNumberDictionaryElement(elements, index)
    otherwise IfHole, IfHole;
  }

  macro JoinToLocaleString(context: Context, element: Object): never
  labels IfEmpty, IfException(Object), IfString(String),
      IfStringWithSideEffects(String) {
    if (IsNullOrUndefined(element)) goto IfEmpty;

    let prop: Object =
      EnsureNotException(GetProperty(context, element, 'toLocaleString'))
      otherwise IfException;
    try {
      let callable: Callable = cast<Callable>(prop) otherwise TypeError;
      let result: Object =
        EnsureNotException(Call(context, callable, element))
        otherwise IfException;
      result =
        EnsureNotException(ToString(context, result))
        otherwise IfException;
      goto IfStringWithSideEffects(unsafe_cast<String>(result));
    }
    label TypeError {
      goto IfException(NewTypeError(context, kCalledNonCallable, prop));
    }
  }

  macro JoinToString<ElementsAccessor: type>(
      context: Context, element: Object): never
  labels IfEmpty, IfException(Object), IfString(String),
      IfStringWithSideEffects(String) {
    if (TaggedIsSmi(element)) {
      goto IfString(SmiToString(unsafe_cast<Smi>(element)));
    } else if (IsString(unsafe_cast<HeapObject>(element))) {
      goto IfString(unsafe_cast<String>(element));
    } else if (IsNullOrUndefined(element)) {
      goto IfEmpty;
    } else {
      // TODO(pwong): Marking this branch's label as kDeferred improves
      // bench/string by 4-5%!
      let result: Object =
        EnsureNotException(ToString(context, element))
        otherwise IfException;
      goto IfStringWithSideEffects(unsafe_cast<String>(result));
    }
  }

  JoinToString<FastHoleySmiElements>(context: Context, element: Object): never
  labels IfEmpty, IfException(Object), IfString(String),
      IfStringWithSideEffects(String) {
    goto IfString(SmiToString(unsafe_cast<Smi>(element)));
  }

  JoinToString<FastHoleyDoubleElements>(
      context: Context, element: Object): never
  labels IfEmpty, IfException(Object), IfString(String),
      IfStringWithSideEffects(String) {
    goto IfString(HeapNumberToString(unsafe_cast<HeapNumber>(element)));
  }

  // Verifies the current element accessor can still be safely used
  // (see Load<ElementsAccessor>). Otherwise go to Cannot.
  macro CanUseSameAccessor<ElementsAccessor: type>(
      originalMap: Object, originalLen: Object, receiver: Object): bool {
    let array: JSArray = unsafe_cast<JSArray>(receiver);
    if (originalMap != array.map) return false;
    if (originalLen != array.length) return false;
    if (IsNoElementsProtectorCellInvalid()) return false;
    return true;
  }

  CanUseSameAccessor<GenericElementsAccessor>(
      originalMap: Object, originalLen: Object, receiver: Object): bool {
    return true;
  }

  macro ArrayJoinImpl<ElementsAccessor: type>(
      useLocale: constexpr bool, context: Context, receiver: Object,
      sep: String, initialString: String, initialIndex: intptr,
      initialLen: Number, initialMap: Object): String
  labels Continuation(intptr, String, String, Number), IfException(Object) {
    // 5. Let R be the empty String.
    let r: String = initialString;
    let elements: Object = LoadReceiverElements<ElementsAccessor>(receiver);
    let len: intptr = convert<intptr>(initialLen);

    // 6. Let k be 0.
    // 7. Repeat, while k < len
    for (let k: intptr = initialIndex; k < len; k++) {
      // a. If k > 0, let R be the string-concatenation of R and sep.
      if (k > 0) r = StringAdd_CheckNone_NotTenured(context, r, sep);
      try {
        // b. Let element be ? Get(O, ! ToString(k)).
        let element: Object = Load<ElementsAccessor>(context, elements, k)
        otherwise Skip, IfException;

        // c. If element is undefined or null, let next be the empty String;
        //    otherwise, let next be ? ToString(element).
        if constexpr (useLocale) {
          JoinToLocaleString(context, element)
          otherwise Skip, IfException, IfString, IfStringWithSideEffects;
        } else {
          JoinToString<ElementsAccessor>(context, element)
          otherwise Skip, IfException, IfString, IfStringWithSideEffects;
        }
      }
      label IfString(next: String) {
        r = StringAdd_CheckNone_NotTenured(context, r, next);
      }
      label IfStringWithSideEffects(next: String) {
        r = StringAdd_CheckNone_NotTenured(context, r, next);

        // If JS code may have been called, there's a possibility the receiver
        // was mutated in a way the current element accessor no longer
        // applies.
        if (!CanUseSameAccessor<ElementsAccessor>(
                initialMap, initialLen, receiver)) {
          goto Continuation(k + 1, r, sep, initialLen);
        }
      }
      label Skip {}

      // d. Increment k by 1.
    }

    // 8. Return R.
    return r;
  }

  builtin ArrayJoinContinuation(
      context: Context, receiver: Object, sep: String, len: Number,
      useLocale: Boolean, initialString: String, initialIndex: Number): Object {
    try {
      let index: intptr = convert<intptr>(initialIndex);
      if (useLocale == True) {
        return ArrayJoinImpl<GenericElementsAccessor>(
            true, context, receiver, sep, initialString, index, len, Undefined)
        otherwise Continuation, IfException;
      } else {
        return ArrayJoinImpl<GenericElementsAccessor>(
            false, context, receiver, sep, initialString, index, len, Undefined)
        otherwise Continuation, IfException;
      }
    }
    label Continuation(initialIndex: intptr, initialString: String,
                       sep: String, len: Number) {
      // By design, ArrayJoinImpl's GenericElementsAccessor element accessor
      // handles all cases and never bails out (see
      // CanUseSameAccessor<GenericElementsAccessor>).
      unreachable;
    }
    label IfException(e: Object) { ReThrowError(context, e); }
  }

  macro JSArrayJoin(
    context: Context, receiver: JSArray, sep: String, len: Number,
    useLocale: constexpr bool): String
  labels Continuation(intptr, String, String, Number), IfException(Object) {
    let map: Map = receiver.map;
    let kind: ElementsKind = map.elements_kind;
    let lenObj: Object = len;
    if (IsPrototypeInitialArrayPrototype(context, map) &&
        !IsNoElementsProtectorCellInvalid() && lenObj == receiver.length) {
      if (TaggedIsSmi(len)) {
        if (kind <= HOLEY_SMI_ELEMENTS) {
          return ArrayJoinImpl<FastHoleySmiElements>(
              useLocale, context, receiver, sep, EmptyString, 0, len, map)
          otherwise Continuation, IfException;
        } else if (kind <= HOLEY_ELEMENTS) {
          return ArrayJoinImpl<FastHoleyObjectElements>(
              useLocale, context, receiver, sep, EmptyString, 0, len, map)
          otherwise Continuation, IfException;
        } else if (kind <= HOLEY_DOUBLE_ELEMENTS) {
          return ArrayJoinImpl<FastHoleyDoubleElements>(
              useLocale, context, receiver, sep, EmptyString, 0, len, map)
          otherwise Continuation, IfException;
        }
      }
      if (kind == DICTIONARY_ELEMENTS &&
          HasComplexElements(context, receiver) == False) {
        let elements: NumberDictionary =
            unsafe_cast<NumberDictionary>(receiver.elements);
        return ArrayJoinImpl<DictionaryElements>(
            useLocale, context, receiver, sep, EmptyString, 0, len, map)
        otherwise Continuation, IfException;
      }
    }
    goto Continuation(0, EmptyString, sep, len);
  }

  macro NormalizeJoinSeperator(context: Context, obj: Object): String {
    // 3. If separator is undefined, let sep be the single-element String ",".
    // 4. Else, let sep be ? ToString(separator).
    return obj == Undefined ? from_constexpr<String>(',')
                            : ToString_Inline(context, obj);
  }

  macro ArrayJoin(context: Context, receiverObj: Object, sepObj: Object,
      useLocale: constexpr bool): Object {
    // 1. Let O be ? ToObject(this value).
    let receiver: JSReceiver = ToObject(context, receiverObj);
    let result: Object = Undefined;
    let exception: Object = Undefined;
    try {
      if (IsJSArray(receiver)) {
        let receiverArray: JSArray = unsafe_cast<JSArray>(receiver);

        // 2. Let len be ? ToLength(? Get(O, "length")).
        let len: Number = receiverArray.length;
        let sep: String = NormalizeJoinSeperator(context, sepObj);
        JoinStackPush(receiverObj) otherwise CycleDetected;
        result = JSArrayJoin(context, receiverArray, sep, len, useLocale)
        otherwise Continuation, IfException;
      } else {
        // 2. Let len be ? ToLength(? Get(O, "length")).
        let lenObj: Object = GetProperty(context, receiver, LengthString);
        let len: Number = ToLength_Inline(context, lenObj);
        let sep: String = NormalizeJoinSeperator(context, sepObj);
        goto Continuation(0, EmptyString, sep, len);
      }
    }
    label Continuation(continueIndex: intptr, initialString: String,
                       sep: String, len: Number) {
      try {
        // TODO(pwong): Test for slow mode exception thrown
        result = EnsureNotException(
          ArrayJoinContinuation(context, receiver, sep, len, useLocale,
                                initialString, convert<Number>(continueIndex))
        ) otherwise IfException;
      }
      label IfException(e: Object) { exception = e; }
    }
    label CycleDetected { return EmptyString; }
    label IfException(e: Object) { exception = e; }

    JoinStackPop(context, receiverObj);
    if (exception != Undefined) ReThrowError(context, exception);
    return result;
  }

  javascript builtin ArrayPrototypeToLocaleString(
      context: Context, receiver: Object): Object {
    return ArrayJoin(context, receiver, Undefined, true);
  }

  javascript builtin ArrayPrototypeJoin(
      context: Context, receiver: Object, sepObj: Object): Object {
    return ArrayJoin(context, receiver, sepObj, false);
  }

  // The Join Stack detects cyclical calls to Array.p.join.  This FixedArray
  // holds a stack of JSArrays that are receivers to the current call
  // to Array.p.join. The Array.p.join builtin is responsible for calling
  // JoinStackPush and JoinStackPop when visiting and leaving a JSArray,
  // respectively.
  extern macro LoadJoinStack(): FixedArray;
  extern macro SetJoinStack(FixedArray): void;
  const kMinJoinStackSize: constexpr int32 generates
  'JSArray::kMinJoinStackSize';

  // Adds a receiver to the stack. The FixedArray will automaticlly grow to
  // accomadate the receiver. If the receiver already exists on the stack,
  // this indicates a cyclical call and CycleDetected will be taken.
  macro JoinStackPush(receiver: Object)
  labels CycleDetected {
    let stack: FixedArray = LoadJoinStack();
    // Fast path the common non-nested join call case.
    if (stack[0] == Hole) {
      stack[0] = receiver;
      return;
    }

    let len: intptr = stack.length_intptr;
    for (let i: intptr = 0; i < len; i++) {
      let previouslyVisited: Object = stack[i];

      // Add `receiver` to the first open slot
      if (previouslyVisited == Hole) {
        stack[i] = receiver;
        return;
      }

      // Detect cycles
      if (receiver == previouslyVisited) goto CycleDetected;
    }

    // If no open slots were found, grow the stack and add receiver to the end.
    // Growth rate is analog to JSObject::NewElementsCapacity:
    // new_capacity = (current_capacity + (current_capacity >> 1)) + 16.
    let capacity: intptr = (len + (len >>> 1)) + 16;
    let newStack: FixedArray =
        ExtractFixedArray(stack, 0, len, capacity, kFixedArrays);
    newStack[len] = receiver;
    SetJoinStack(newStack);
  }

  // Removes a receiver from the stack. The FixedArray will automaticlly shrink
  // to Heap::kMinJoinStackSize once the stack becomes empty.
  builtin JoinStackPop(context: Context, receiver: Object): Object {
    let stack: FixedArray = LoadJoinStack();
    let len: intptr = stack.length_intptr;
    try {
      for (let i: intptr = 0; i < len; i++) {
        let el: Object = stack[i];
        if (el == receiver) goto RemoveAndShrink(i);
        if (el == Hole) return Undefined;
      }
      unreachable;
    }
    label RemoveAndShrink(i: intptr) {
      stack[i] = Hole;
      if (i == 0 && len > kMinJoinStackSize) {
        // TODO(pwong): Should be passing AllocationFlags, torque compiler error
        let newStack: FixedArray =
            AllocateFixedArray(PACKED_ELEMENTS, IntPtrConstant(kMinJoinStackSize));
        assert(kMinJoinStackSize == 2);
        newStack[0] = Hole;
        newStack[1] = Hole;
        SetJoinStack(newStack);
      }
    }
    return Undefined;
  }
}
