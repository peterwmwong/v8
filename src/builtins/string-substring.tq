// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace string {

const kFlagStringSlices: constexpr bool generates 'FLAG_string_slices';

extern macro StringBuiltinsAssembler::IncrementCounterSubStringNative(): void;

// TODO(pwong): Audit usages of StringSubstring and verify whether it was
// originally calling the inline or builtin version.

macro SubstringInline(string: String, from: uintptr, to: uintptr): String {
  const length = Convert<intptr>(to - from);
  assert(from <= to);
  assert(length <= string.length_intptr);
  if (length == string.length_intptr) return string;
  if (length == 0) return kEmptyString;

  const slice = string.Slice(from, to);
  if constexpr (kFlagStringSlices) {
    if (slice.length >= kSlicedStringMinLength) {
      IncrementCounterSubStringNative();
      return new SlicedString{
        map: slice.isOneByte ? kSlicedOneByteStringMap : kSlicedStringMap,
        raw_hash_field: kNameEmptyHashField,
        length: Convert<int32>(slice.length),
        parent: slice.root,
        offset: Convert<Smi>(slice.rootOffset)
      };
    }
  }
  // Optimization: Reduce generated code by consolidating the following cases
  // needing to allocate a string into a single allocation point:
  // 1. {length} is greater than 1.
  // 2. {length} is 1, {singleChar} is one byte representable, but does not have
  //    an associated cached string in kSingleCharacterStringCache.
  // 3. {length} is 1, {singleChar} needs two bytes to be represented.

  // If {length} is 1, {singleChar} is the first/only character code of the
  // substring. Otherwise, {singleChar} is a marker value (character code not
  // one byte representable) indicating {result} should not be cached in
  // kSingleCharacterStringCache.
  let singleChar: uintptr = kMaxOneByteCharCode + 1;
  let isOneByte = slice.isOneByte;
  let charByteLength = slice.ByteLength();
  if (slice.length == 1) {
    // Even if {singleChar} is from a two byte string, it may be one byte
    // representable. If so, attempt to use a cached string from
    // kSingleCharacterStringCache.
    singleChar = Convert<uintptr>(slice.AtIndex(0));
    if (singleChar <= kMaxOneByteCharCode) {
      const cached = kSingleCharacterStringCache.objects[singleChar];
      if (cached != Undefined) return UnsafeCast<String>(cached);

      // If no cached string exists, allocate a one byte string and cache it.
      isOneByte = true;
      charByteLength = 1;
    }
  }

  // Optimization: Reduce generated code by generating a single allocation point
  // for both one and two byte sequential strings.
  // Allocates a two byte string as if it were a one byte string with
  // twice as many characters and then update with the appropriate map and
  // character length.
  const result =
      AllocateNonEmptySeqOneByteString(Convert<uint32>(charByteLength), slice);
  if (!isOneByte) {
    // Map for non-internalilzed SeqTwoByteString
    *UnsafeConstCast(&result.map) = kStringMap;
    *UnsafeConstCast(&result.length) = Convert<int32>(slice.length);
  }

  // If {length} is 1, {singleChar} is one byte representable, and was not
  // already cached, then cache {result} in kSingleCharacterStringCache.
  if (singleChar <= kMaxOneByteCharCode) {
    assert(result.length == 1);
    assert(kSingleCharacterStringCache.objects[singleChar] == Undefined);
    kSingleCharacterStringCache.objects[singleChar] = result;
  }

  return result;
}

// Return a new string object which holds a substring containing the range
// [from,to[ of string.
builtin StringSubstring(implicit context: Context)(
    s: String, from: uintptr, to: uintptr): String {
  return SubstringInline(s, from, to);
}

// ES6 #sec-string.prototype.substring
transitioning javascript builtin StringPrototypeSubstring(
    js-implicit context: NativeContext, receiver: JSAny)(...arguments): String {
  // Check that {receiver} is coercible to Object and convert it to a String.
  const string: String = ToThisString(receiver, 'String.prototype.substring');
  const length: uintptr = string.length_uintptr;

  // Conversion and bounds-checks for {start}.
  const arg0 = arguments[0];
  let start: uintptr = arg0 != Undefined ? ClampToIndexRange(arg0, length) : 0;

  // Conversion and bounds-checks for {end}.
  const arg1 = arguments[1];
  let end: uintptr =
      arg1 != Undefined ? ClampToIndexRange(arg1, length) : length;
  if (end < start) {
    const tmp: uintptr = end;
    end = start;
    start = tmp;
  }
  return SubstringInline(string, start, end);
}
}
