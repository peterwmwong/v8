// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace string {

const kFlagStringSlices: constexpr bool generates 'FLAG_string_slices';

macro SubstringInline(string: String, from: uintptr, to: uintptr): String {
  const length = Convert<intptr>(to - from);
  assert(from <= to);
  assert(length <= string.length_intptr);
  if (length == string.length_intptr) return string;
  if (length == 0) return kEmptyString;

  const slice = string.Slice(from, to);
  if constexpr (kFlagStringSlices) {
    if (slice.length >= kSlicedStringMinLength) {
      return new SlicedString{
        map: slice.isOneByte ? kSlicedOneByteStringMap : kSlicedStringMap,
        raw_hash_field: kNameEmptyHashField,
        length: Convert<int32>(slice.length),
        parent: slice.root,
        offset: Convert<Smi>(slice.rootOffset)
      };
    }
  }

  if (slice.length == 1) {
    // Even if {singleChar} is from a two byte string, it may be one byte
    // representable. If so, attempt to use a cached string from
    // kSingleCharacterStringCache.
    const singleChar = slice.AtIndex(0);
    if (singleChar <= kMaxOneByteCharCode) deferred {
        let result = &kSingleCharacterStringCache
                         .objects[Convert<uintptr>(singleChar)];
        if (*result == Undefined) {
          *result = AllocateNonEmptySeqOneByteString(
              1, ConstantIterator(%RawDownCast<char8>(singleChar)));
        }
        return UnsafeCast<String>(*result);
      }
  }

  // TODO(pwong): Re-verify optimization. Compare with CharSlice() w/2
  // Allocation Points. Optimization: Reduce generated code by generating a
  // single allocation point. Allocates sequential strings by byte (char8) size
  // and copy character data on a byte by byte basis (see
  // InitializeFieldsFromIterator<char8, StringSlice>). Afterwards, the map and
  // length are updated appropriately for a two byte string.
  const lengthUint32 = Convert<uint32>(Unsigned(slice.length));
  try {
    slice.Chars() otherwise OneByte, TwoByte;
  } label OneByte(s: ConstSlice<char8>) {
    return AllocateNonEmptySeqOneByteString(lengthUint32, s);
  } label TwoByte(s: ConstSlice<char16>) {
    return AllocateNonEmptySeqTwoByteString(lengthUint32, s);
  }
}

// Return a new string object which holds a substring containing the range
// [from,to[ of string.
builtin StringSubstring(implicit context: Context)(
    s: String, from: uintptr, to: uintptr): String {
  return SubstringInline(s, from, to);
}

// ES6 #sec-string.prototype.substring
transitioning javascript builtin StringPrototypeSubstring(
    js-implicit context: NativeContext, receiver: JSAny)(...arguments): String {
  // Check that {receiver} is coercible to Object and convert it to a String.
  const string: String = ToThisString(receiver, 'String.prototype.substring');
  const length: uintptr = string.length_uintptr;

  // Conversion and bounds-checks for {start}.
  const arg0 = arguments[0];
  let start: uintptr = arg0 != Undefined ? ClampToIndexRange(arg0, length) : 0;

  // Conversion and bounds-checks for {end}.
  const arg1 = arguments[1];
  let end: uintptr =
      arg1 != Undefined ? ClampToIndexRange(arg1, length) : length;
  if (end < start) {
    const tmp: uintptr = end;
    end = start;
    start = tmp;
  }
  return SubstringInline(string, start, end);
}
}
