// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// TODO(pwong): ...
// - Convert SubStringImpl to not be generic (only code generate once)
//    - Single Char
//    - WriteToString
//    - Sliced String
// - Add an specialization of InitializeFieldsFromIterator using RawPtr
// (basically WriteToString)

namespace string {

// extern macro AllocateSlicedOneByteString(uint32, String, Smi): String;
// extern macro AllocateSlicedTwoByteString(uint32, String, Smi): String;

extern macro StringBuiltinsAssembler::LoadChar8(RawPtr, uintptr): char8;
extern macro StringBuiltinsAssembler::LoadChar16(RawPtr, uintptr): char16;
extern macro StringBuiltinsAssembler::StoreChar8(RawPtr, uintptr, char8): void;

const kSlicedStringMinLength:
    constexpr int31 generates 'SlicedString::kMinLength';

// extern macro SingleCharacterStringCacheConstant(): FixedArray;
// extern macro UnsafeLoadFixedArrayElement(FixedArray, intptr): Object;
// const kSingleCharacterStringCache: FixedArray =
//     SingleCharacterStringCacheConstant();
// const kMaxOneByteCharCode:
//     constexpr int32 generates 'String::kMaxOneByteCharCode';
// macro StringFromSingleCharCode2(char: char8|char16): String {
//   const charInt = Convert<intptr>(Convert<int32>(char));
//   if (Convert<int32>(char) <= kMaxOneByteCharCode) {
//     const maybeString =
//         UnsafeLoadFixedArrayElement(kSingleCharacterStringCache, charInt);
//     if (maybeString != Undefined) {
//       return UnsafeCast<String>(maybeString);
//     } else
//       deferred {
//         const result = AllocateNonEmptySeqOneByteString(
//             1, ConstantIterator(%RawDownCast<char8>(char)));
//         kSingleCharacterStringCache.objects[charInt] = result;
//         return result;
//       }
//   } else
//     deferred {
//       return AllocateNonEmptySeqTwoByteString(
//           1, ConstantIterator(%RawDownCast<char16>(char)));
//     }
// }

// macro AllocateSlicedString<T: type>(
//     length: uint32, parent: String, offset: intptr): String;
// AllocateSlicedString<char8>(
//     length: uint32, parent: String, offset: intptr): String {
//   return AllocateSlicedOneByteString(length, parent, SmiTag(offset));
// }
// AllocateSlicedString<char16>(
//     length: uint32, parent: String, offset: intptr): String {
//   return AllocateSlicedTwoByteString(length, parent, SmiTag(offset));
// }

// macro WriteToString(srcPtr: RawPtr, byteLength: uint32): String {
//   try {
//     AllocateSeqString<T>(length) otherwise AllocatedString;
//   } label AllocatedString(dest: String, destChars: ConstSlice<T>) {
//     const destPtr = destChars.GCUnsafeStartPointer();
//     const byteLength =
//         Unsigned(torque_internal::TimesSizeOf<T>(Convert<intptr>(length)));
//     let i: uintptr = 0;
//     while (true) {
//       StoreChar8(destPtr, i, LoadChar8(srcPtr, i));
//       if (++i == byteLength) break;
//     }
//     return dest;
//   }
// }

// macro SubStringImpl<T: type>(
//     srcParent: String, srcParentOffset: intptr, src: ConstSlice<T>,
//     from: uintptr, length: uint32): String {
//   const fromInt = Convert<intptr>(from);
//   if (length == 1) {
//     return StringFromSingleCharCode(*src.AtIndex(fromInt));
//   }
//   if (length < kSlicedStringMinLength) {
//     return WriteToString(src, fromInt, length);
//   }
//   return AllocateSlicedString<T>(length, srcParent, srcParentOffset +
//   fromInt);
// }

macro SubString(string: String, from: uintptr, to: uintptr): String {
  const length = Convert<uint32>(to - from);
  assert(length <= string.length_uint32);
  if (length == string.length_uint32) return string;
  if (length == 0) return kEmptyString;

  const fromInt = Convert<intptr>(from);
  let root: String;
  let rootCharOffset: intptr;
  let rootChars: RawPtr;
  let isOneByte: bool;
  try {
    StringToRootStringAndOffset(string) otherwise OneByte, TwoByte,
        OneByteExternal, TwoByteExternal;
  } label OneByte(r: SeqOneByteString, o: intptr) {
    root = r;
    rootCharOffset = o;
    rootChars = r.GetChars() + torque_internal::TimesSizeOf<char8>(o + fromInt);
    isOneByte = true;
  } label TwoByte(r: SeqTwoByteString, o: intptr) {
    root = r;
    rootCharOffset = o;
    rootChars =
        r.GetChars() + torque_internal::TimesSizeOf<char16>(o + fromInt);
    isOneByte = false;
  } label OneByteExternal(r: ExternalOneByteString, o: intptr) {
    root = r;
    rootCharOffset = o;
    rootChars = r.GetChars() + torque_internal::TimesSizeOf<char8>(o + fromInt);
    isOneByte = true;
  } label TwoByteExternal(r: ExternalTwoByteString, o: intptr) {
    root = r;
    rootCharOffset = o;
    rootChars =
        r.GetChars() + torque_internal::TimesSizeOf<char16>(o + fromInt);
    isOneByte = false;
  }

  if (length == 1) {
    return StringFromSingleCharCode(
        isOneByte ? LoadChar8(rootChars, 0) : LoadChar16(rootChars, 0));
  }
  if (length < kSlicedStringMinLength) {
    let result: String;
    let destChars: RawPtr;
    if (isOneByte) {
      const str = AllocateNonEmptySeqOneByteString(length);
      result = str;
      destChars = (&str.chars).GCUnsafeStartPointer();
    } else {
      const str = AllocateNonEmptySeqTwoByteString(length);
      result = str;
      destChars = (&str.chars).GCUnsafeStartPointer();
    }
    const byteLength = isOneByte ?
        Unsigned(Convert<intptr>(length)) :
        Unsigned(torque_internal::TimesSizeOf<char16>(Convert<intptr>(length)));
    let i: uintptr = 0;
    while (true) {
      StoreChar8(destChars, i, LoadChar8(rootChars, i));
      if (++i == byteLength) break;
    }
    return result;
  }

  const map = isOneByte ? kSlicedOneByteStringMap : kSlicedStringMap;
  return AllocateSlicedString(
      map, length, root, Convert<Smi>(rootCharOffset + fromInt));
}

builtin SubString(implicit context: Context)(
    s: String, from: Smi, to: Smi): String {
  return SubString(
      s, Unsigned(Convert<intptr>(from)), Unsigned(Convert<intptr>(to)));
}

builtin StringSubstring(implicit context: Context)(
    s: String, from: intptr, to: intptr): String {
  return SubString(s, Unsigned(from), Unsigned(to));
}

// ES6 #sec-string.prototype.substring
transitioning javascript builtin StringPrototypeSubstring(
    js-implicit context: NativeContext, receiver: JSAny)(...arguments): String {
  // Check that {receiver} is coercible to Object and convert it to a String.
  const string: String = ToThisString(receiver, 'String.prototype.substring');
  const length: uintptr = string.length_uintptr;

  // Conversion and bounds-checks for {start}.
  const arg0 = arguments[0];
  let start: uintptr = arg0 != Undefined ? ClampToIndexRange(arg0, length) : 0;

  // Conversion and bounds-checks for {end}.
  const arg1 = arguments[1];
  let end: uintptr =
      arg1 != Undefined ? ClampToIndexRange(arg1, length) : length;
  if (end < start) {
    const tmp: uintptr = end;
    end = start;
    start = tmp;
  }
  return SubString(string, start, end);
}
}
