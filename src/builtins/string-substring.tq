// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

namespace string {

const kSlicedStringMinLength:
    constexpr int31 generates 'SlicedString::kMinLength';

extern macro SingleCharacterStringCacheConstant(): FixedArray;
const kSingleCharacterStringCache: FixedArray =
    SingleCharacterStringCacheConstant();
const kMaxOneByteCharCode:
    constexpr int31 generates 'String::kMaxOneByteCharCode';

macro SubStringSmallImpl(
    isOneByte: bool, srcChars: RawPtr, length: intptr): String {
  const byteLength = Unsigned(
      isOneByte ? torque_internal::TimesSizeOf<char8>(length) :
                  torque_internal::TimesSizeOf<char16>(length));
  const str = AllocateNonEmptySeqOneByteString(
      Convert<uint32>(byteLength), %RawDownCast<RawPtr<char8>>(srcChars));
  if (!isOneByte) {
    *UnsafeConstCast(&str.map) = kStringMap;
    *UnsafeConstCast(&str.length) = Convert<int32>(length);
  }
  return str;
}

macro SubString(string: String, from: uintptr, to: uintptr): String {
  assert(from <= to);
  const length = Convert<intptr>(to - from);
  assert(length <= string.length_intptr);
  if (length == string.length_intptr) return string;
  if (length == 0) return kEmptyString;

  const from = Convert<intptr>(from);
  try {
    StringToRootOffsetSlice(string) otherwise OneByte, TwoByte;
  } label OneByte(src: String, srcOffset: intptr, slice: ConstSlice<char8>) {
    goto DoSubString(
        src, srcOffset,
        // TODO(pwong): use ConstSlice and Subslice
        (slice.GCUnsafeStartPointer() +
         torque_internal::TimesSizeOf<char8>(from)),
        true);
  } label TwoByte(src: String, srcOffset: intptr, slice: ConstSlice<char16>) {
    goto DoSubString(
        src, srcOffset,
        (slice.GCUnsafeStartPointer() +
         torque_internal::TimesSizeOf<char16>(from)),
        false);
  } label DoSubString(
      src: String, srcOffset: intptr, srcChars: RawPtr, isOneByte: bool) {
    if (length >= kSlicedStringMinLength) {
      return new SlicedString{
        map: isOneByte ? kSlicedOneByteStringMap : kSlicedStringMap,
        raw_hash_field: kNameEmptyHashField,
        length: Convert<int32>(length),
        parent: src,
        offset: Convert<Smi>(srcOffset + from)
      };
    }

    let isOneByte = isOneByte;
    let singleChar: intptr = kMaxOneByteCharCode + 1;
    if (length == 1) {
      // TODO(pwong): Factor out GetSingleCharacterCodeString() labels
      // NotCached;
      singleChar = Convert<intptr>(Convert<int32>(
          isOneByte ? LoadChar8(srcChars, 0) : LoadChar16(srcChars, 0)));
      if (singleChar <= kMaxOneByteCharCode) {
        isOneByte = true;
        const cached = kSingleCharacterStringCache.objects[singleChar];
        // TODO(pwong): UnsafeCast?
        // TODO(pwong): Is<String>? or atleast assert(Is<String>)
        if (cached != Undefined) return %RawDownCast<String>(cached);
      }
    }

    const result = SubStringSmallImpl(isOneByte, srcChars, length);
    if (singleChar <= kMaxOneByteCharCode)
      kSingleCharacterStringCache.objects[singleChar] = result;
    return result;
  }
}

builtin SubString(implicit context: Context)(
    s: String, from: Smi, to: Smi): String {
  return SubString(
      s, Unsigned(Convert<intptr>(from)), Unsigned(Convert<intptr>(to)));
}

builtin StringSubstring(implicit context: Context)(
    s: String, from: intptr, to: intptr): String {
  return SubString(s, Unsigned(from), Unsigned(to));
}

// ES6 #sec-string.prototype.substring
transitioning javascript builtin StringPrototypeSubstring(
    js-implicit context: NativeContext, receiver: JSAny)(...arguments): String {
  // Check that {receiver} is coercible to Object and convert it to a String.
  const string: String = ToThisString(receiver, 'String.prototype.substring');
  const length: uintptr = string.length_uintptr;

  // Conversion and bounds-checks for {start}.
  const arg0 = arguments[0];
  let start: uintptr = arg0 != Undefined ? ClampToIndexRange(arg0, length) : 0;

  // Conversion and bounds-checks for {end}.
  const arg1 = arguments[1];
  let end: uintptr =
      arg1 != Undefined ? ClampToIndexRange(arg1, length) : length;
  if (end < start) {
    const tmp: uintptr = end;
    end = start;
    start = tmp;
  }
  return SubString(string, start, end);
}
}
