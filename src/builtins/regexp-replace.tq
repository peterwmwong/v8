// Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include 'src/builtins/builtins-regexp-gen.h'

namespace regexp_replace {

  extern builtin
  StringIndexOf(implicit context: Context)(String, String, Smi): Smi;
  extern builtin
  SubString(implicit context: Context)(String, Smi, Smi): String;

  extern runtime RegExpExecMultiple(implicit context: Context)(
      JSRegExp, String, RegExpMatchInfo, JSArray): Null | JSArray;
  extern transitioning runtime
  RegExpReplaceRT(Context, JSReceiver, String, Object): String;
  extern transitioning runtime
  StringBuilderConcat(implicit context: Context)(JSArray, Smi, String): String;
  extern transitioning runtime
  StringReplaceNonGlobalRegExpWithFunction(implicit context: Context)(
      String, JSRegExp, Callable): String;

  // TODO(pwong): consider supporting special keyword replacement `$`.
  // extern macro StringBuiltinsAssembler::GetSubstitution(
  //   implicit context: Context)(String, Smi, Smi, String): String;

  // Fast
  extern macro
  RegExpBuiltinsAssembler::AdvanceStringIndex(String, Smi, bool): Smi;
  // Slow
  extern macro
  RegExpBuiltinsAssembler::AdvanceStringIndex(String, Number, bool): Number;
  extern macro
  RegExpBuiltinsAssembler::CallJSRegExpRegExpReplaceToSequentialString(
      String, FixedArray, intptr, String, String): String;

  // TODO(pwong): Consider optimizing to pass `collectCaptures: bool` to collect
  // capture start/end indices or not.
  extern macro
  RegExpBuiltinsAssembler::RegExpPrototypeExecBodyWithoutResult(
      implicit context: Context)(JSReceiver, String, constexpr bool):
      RegExpMatchInfo labels IfDidNotMatch;

  macro AdvanceLastIndex<T: type>(implicit context:
                                       Context)(rx: T, string: String) {
    rx.lastIndex = AdvanceStringIndex(string, rx.lastIndex, rx.unicode);
  }

  macro IsTypeEqual<T: type, U: type>(): constexpr bool {
    return false;
  }
  IsTypeEqual<FastJSRegExp, FastJSRegExp>(): constexpr bool {
    return true;
  }

  transitioning macro RegExpReplaceCallableNoExplicitCaptures(implicit context:
                                                                  Context)(
      matchesElements: FixedArray, matchesLength: intptr, string: String,
      replaceFn: Callable) {
    let matchStart: Smi = 0;
    for (let i: intptr = 0; i < matchesLength; i++) {
      typeswitch (matchesElements.objects[i]) {
        // Element represents a slice.
        case (elSmi: Smi): {
          // The slice's match start and end is either encoded as one or two
          // smis. A positive smi indicates a single smi encoding (see
          // ReplacementStringBuilder::AddSubjectSlice()).
          if (elSmi > 0) {
            // For single smi encoding, see
            // StringBuilderSubstringLength::encode() and
            // StringBuilderSubstringPosition::encode().
            const elInt: intptr = Convert<intptr>(elSmi);
            const newMatchStart: intptr = (elInt >> 11) + (elInt & 0x7FF);
            matchStart = Convert<Smi>(newMatchStart);
          } else {
            // For two smi encoding, the length is negative followed by the
            // match start.
            const nextEl: Smi = UnsafeCast<Smi>(matchesElements.objects[++i]);
            matchStart = nextEl - elSmi;
          }
        }
        // Element represents the matched substring, which is then passed to the
        // replace function.
        case (elString: String): {
          const replacementObj: Object =
              Call(context, replaceFn, Undefined, elString, matchStart, string);
          const replacement: String = ToString_Inline(context, replacementObj);
          matchesElements.objects[i] = replacement;
          matchStart += elString.length_smi;
        }
        case (Object): deferred {
          unreachable;
        }
      }
    }
  }

  transitioning macro
  RegExpReplaceCallableWithExplicitCaptures(implicit context: Context)(
      matchesElements: FixedArray, matchesLength: intptr, string: String,
      replaceFn: Callable) {
    for (let i: intptr = 0; i < matchesLength; i++) {
      const elArray =
          Cast<JSArray>(matchesElements.objects[i]) otherwise continue;

      // The JSArray is expanded into the function args by Reflect.apply().
      // TODO(jgruber): Remove indirection through Call->ReflectApply.
      const replacementObj: Object = Call(
          context, GetReflectApply(), Undefined, replaceFn, Undefined, elArray);

      // Overwrite the i'th element in the results with the string
      // we got back from the callback function.
      matchesElements.objects[i] = ToString_Inline(context, replacementObj);
    }
  }

  transitioning macro RegExpReplaceFastGlobalCallable(implicit context:
                                                          Context)(
      regexp: FastJSRegExp, string: String, replaceFn: Callable): String {
    regexp.lastIndex = 0;

    const kInitialCapacity: Smi = 16;
    const kInitialLength: Smi = 0;
    const result: Null | JSArray = RegExpExecMultiple(
        regexp, string, GetRegExpLastMatchInfo(),
        AllocateJSArray(
            PACKED_ELEMENTS, GetFastPackedElementsJSArrayMap(),
            kInitialCapacity, kInitialLength));

    regexp.lastIndex = 0;

    // If no matches, return the subject string.
    if (result == Null) return string;

    const matches: JSArray = UnsafeCast<JSArray>(result);
    const matchesLength: Smi = Cast<Smi>(matches.length) otherwise unreachable;
    const matchesLengthInt: intptr = Convert<intptr>(matchesLength);
    const matchesElements: FixedArray =
        UnsafeCast<FixedArray>(matches.elements);

    // Reload last match info since it might have changed.
    const nofCaptures: Smi = GetRegExpLastMatchInfo().NumberOfCaptures();

    // If the number of captures is two then there are no explicit captures in
    // the regexp, just the implicit capture that captures the whole match. In
    // this case we can simplify quite a bit and end up with something faster.
    if (nofCaptures == 2) {
      RegExpReplaceCallableNoExplicitCaptures(
          matchesElements, matchesLengthInt, string, replaceFn);
    } else {
      RegExpReplaceCallableWithExplicitCaptures(
          matchesElements, matchesLengthInt, string, replaceFn);
    }

    return StringBuilderConcat(matches, matchesLength, string);
  }

  type RegExpMatchInfoOrNull = RegExpMatchInfo | Null;
  type RegExpExecFn = builtin(Context, JSReceiver, String) =>
      RegExpMatchInfoOrNull;

  transitioning builtin RegExpPrototypeExecBodyWithoutResult<T: type>(
      context: Context, regexp: JSReceiver,
      string: String): RegExpMatchInfoOrNull {
    const kIsFast: constexpr bool = IsTypeEqual<FastJSRegExp, T>();
    return RegExpPrototypeExecBodyWithoutResult(regexp, string, kIsFast)
        otherwise return Null;
  }

  type GetReplacementFn = builtin(Context, Object, String, RegExpMatchInfo) =>
      String;

  transitioning builtin GetReplacementForString(
      context: Context, replacer: Object, inputString: String,
      match: RegExpMatchInfo): String {
    const replaceString: String = Cast<String>(replacer) otherwise unreachable;
    return replaceString;
  }

  macro ResetLastIndexIfGlobal<T: type>(implicit context: Context)(rx: T):
      bool {
    const global: bool = rx.global;
    if (global) rx.lastIndex = 0;
    return global;
  }

  struct GrowableFixedArray {
    Push(implicit context: Context)(obj: Object) {
      this.EnsureCapacity();
      this.array.objects[this.length++] = obj;
    }
    Push(implicit context: Context)(smi: Smi) {
      this.EnsureCapacity();
      this.array.objects[this.length++] = smi;
    }
    Push2(implicit context: Context)(smi: Smi, smi2: Smi) {
      this.EnsureCapacity2();
      this.array.objects[this.length++] = smi;
      this.array.objects[this.length++] = smi2;
    }
    ResizeFixedArray(implicit context: Context)(newCapacity: intptr):
        FixedArray {
      assert(this.length >= 0);
      assert(newCapacity >= 0);
      assert(newCapacity >= this.length);
      const first: intptr = 0;
      return UnsafeCast<FixedArray>(ExtractFixedArray(
          this.array, first, this.length, newCapacity, kFixedArrays));
    }
    EnsureCapacity(implicit context: Context)() {
      assert(this.length <= this.capacity);
      if (this.capacity == this.length) {
        // Growth rate is analog to JSObject::NewElementsCapacity:
        // new_capacity = (current_capacity + (current_capacity >> 1)) + 16.
        this.capacity = this.capacity + (this.capacity >> 1) + 16;
        this.array = this.ResizeFixedArray(this.capacity);
      }
    }
    EnsureCapacity2(implicit context: Context)() {
      const capacity = this.capacity;
      assert(this.length <= capacity);
      if (this.length >= capacity - 1) {
        // Growth rate is analog to JSObject::NewElementsCapacity:
        // new_capacity = (current_capacity + (current_capacity >> 1)) + 16.
        this.capacity = capacity + (capacity >> 1) + 16;
        this.array = this.ResizeFixedArray(this.capacity);
      }
    }

    array: FixedArray;
    capacity: intptr;
    length: intptr;
  }

  macro NewGrowableFixedArray(): GrowableFixedArray {
    const kInitialCapacity: intptr = 16;
    // return GrowableFixedArray{array: AllocateFixedArrayWithHoles(kInitialCapacity, kNone), capacity: kInitialCapacity, length: 0};
    return GrowableFixedArray{array: kEmptyFixedArray, capacity: 0, length: 0};
  }

  // type AddMatchFn =
  //     builtin(Context, GrowableFixedArray, Smi, Smi, RegExpMatchInfo) =>
  //     Object;
  type FinalizeFn = builtin(Context, FixedArray, Smi, Smi, String, Object) =>
      String;

  // builtin AddMatchForStringReplacement(
  //     context: Context, acc: GrowableFixedArray, matchStart: Smi, matchEnd:
  //     Smi, match: RegExpMatchInfo): Object {
  //   acc.Push(matchStart);
  //   acc.Push(matchEnd);
  //   return Undefined;
  // }

  // TODO(pwong): Rename totalMatchLength
  // TODO(pwong): Bitcast Smis
  builtin FinalizeWithStringReplacement(
      context: Context, matches: FixedArray, matchesLength: Smi,
      totalMatchLength: Smi, string: String, replaceObj: Object): String {
    const replace = UnsafeCast<String>(replaceObj);
    const isOneByte: bool = IsOneByteStringInstanceType(string.instanceType) &
        IsOneByteStringInstanceType(replace.instanceType);
    const matchesLengthInt = Convert<intptr>(matchesLength);
    const nofChars = Convert<intptr>(totalMatchLength) +
        replace.length_intptr * (matchesLengthInt >> 1);
    const length = Convert<uint32>(Unsigned(nofChars));
    const dest: String = isOneByte ? AllocateSeqOneByteString(length) :
                                     AllocateSeqTwoByteString(length);
    return CallJSRegExpRegExpReplaceToSequentialString(
        string, matches, matchesLengthInt, replace, dest);
  }

  macro FinalizeWithStringReplacement2(
      context: Context, matches: FixedArray, matchesLength: Smi,
      totalMatchLength: Smi, string: String, replaceObj: Object): String {
    const replace = UnsafeCast<String>(replaceObj);
    const isOneByte: bool = IsOneByteStringInstanceType(string.instanceType) &
        IsOneByteStringInstanceType(replace.instanceType);
    const matchesLengthInt = Convert<intptr>(matchesLength);
    const nofChars = Convert<intptr>(totalMatchLength) +
        replace.length_intptr * (matchesLengthInt >> 1);
    const length = Convert<uint32>(Unsigned(nofChars));
    const dest: String = isOneByte ? AllocateSeqOneByteString(length) :
                                     AllocateSeqTwoByteString(length);
    return CallJSRegExpRegExpReplaceToSequentialString(
        string, matches, matchesLengthInt, replace, dest);
  }

  struct Processor {
    Process(implicit context: Context)(
        string: String, replacer: Object): String {
      // const addMatchFn: AddMatchFn = this.addMatchFn;
      const regexp: FastJSRegExp =
          Cast<FastJSRegExp>(this.regexp) otherwise unreachable;
      let matches: GrowableFixedArray = NewGrowableFixedArray();
      let lastMatchEnd: Smi = 0;
      let unmatchedLength: Smi = 0;
      while (true) {
        // const regexpExecFn: RegExpExecFn = this.regexpExecFn;
        // const matchOrNull: RegExpMatchInfoOrNull =
        //     regexpExecFn(context, regexp, string);
        // if (matchOrNull == Null) break;
        // const match: RegExpMatchInfo =
        //     %RawDownCast<RegExpMatchInfo>(matchOrNull);

        const kIsFast: constexpr bool = true;
        const match: RegExpMatchInfo = RegExpPrototypeExecBodyWithoutResult(
            regexp, string, kIsFast) otherwise break;
        const matchStart: Smi = match.GetStartOfCapture(0);
        const matchEnd: Smi = match.GetEndOfCapture(0);
        // addMatchFn(context, matches, matchStart, matchEnd, match);
        matches.Push2(matchStart, matchEnd);
        // matches.Push(matchStart);
        // matches.Push(matchEnd);
        unmatchedLength += (matchStart - lastMatchEnd);
        lastMatchEnd = matchEnd;

        // Non-global case ends here after the first replacement.
        if (!this.global) break;

        // If match is the empty string, we have to increment lastIndex.
        if (matchEnd == matchStart) deferred {
            // try {
              const fastRegexp = Cast<FastJSRegExp>(regexp) otherwise unreachable;
              AdvanceLastIndex(fastRegexp, string);
            // }
            // label Slow {
            //   // TODO(pwong): tecnically this should ONLY happen if we're
            //   // already on the slow path. assert(this.regexpExecFn ==
            //   // RegExpPrototypeExecBodyWithoutResult<JSRegExp>);
            //   this.regexpExecFn =
            //       RegExpPrototypeExecBodyWithoutResult<JSRegExp>;
            //   AdvanceLastIndex(regexp, string);
            // }
          }
      }

      const matchesLength: intptr = matches.length;
      // TODO(pwong): decreased perf
      // if (matchesLength == 0) deferred {
      //   return string;
      // }

      unmatchedLength += (string.length_smi - lastMatchEnd);
      const finalizeFn: FinalizeFn = this.finalizeFn;
      // return finalizeFn(
      return FinalizeWithStringReplacement2(
          context, matches.array, Convert<Smi>(matchesLength), unmatchedLength,
          string, replacer);
    }

    const regexp: JSRegExp;
    const unicode: bool;
    const global: bool;
    regexpExecFn: RegExpExecFn;
    // const addMatchFn: AddMatchFn;
    const finalizeFn: FinalizeFn;
  }

  macro NewProcessor<T: type>(implicit context: Context)(
      regexp: T, finalizeFn: FinalizeFn): Processor {
    return Processor{
      regexp,
      unicode: regexp.unicode,
      global: ResetLastIndexIfGlobal(regexp),
      regexpExecFn: RegExpPrototypeExecBodyWithoutResult<T>,
      // addMatchFn: AddMatchForStringReplacement,
      finalizeFn
    };
  }

  macro NewProcessorForSimpleStringReplacement(implicit context: Context)(
      regexp: JSRegExp): Processor {
    try {
      const fastRegexp = Cast<FastJSRegExp>(regexp) otherwise Slow;
      return NewProcessor(fastRegexp, FinalizeWithStringReplacement);
    }
    label Slow deferred {
      return NewProcessor(regexp, FinalizeWithStringReplacement);
    }
  }

  transitioning macro RegExpReplaceFastString(implicit context: Context)(
      regexp: FastJSRegExp, string: String, replaceString: String): String {
    // The fast path is reached only if {receiver} is an unmodified JSRegExp
    // instance, {replace_value} is non-callable, and ToString({replace_value})
    // does not contain '$', i.e. we're doing a simple string replacement.
    let result: String = kEmptyString;
    let lastMatchEnd: Smi = 0;
    let unicode: bool = false;
    let replaceLength: Smi = replaceString.length_smi;
    const global: bool = regexp.global;

    if (global) {
      unicode = regexp.unicode;
      regexp.lastIndex = 0;
    }

    while (true) {
      const match: RegExpMatchInfo = RegExpPrototypeExecBodyWithoutResult(
          regexp, string, true) otherwise break;
      const matchStart: Smi = match.GetStartOfCapture(0);
      const matchEnd: Smi = match.GetEndOfCapture(0);

      result = result + SubString(string, lastMatchEnd, matchStart);
      lastMatchEnd = matchEnd;

      if (replaceLength != 0) result = result + replaceString;

      // Non-global case ends here after the first replacement.
      if (!global) break;

      // If match is the empty string, we have to increment lastIndex.
      if (matchEnd == matchStart) {
        AdvanceLastIndex(regexp, string);
      }
    }

    return result + SubString(string, lastMatchEnd, string.length_smi);
  }

  transitioning macro RegExpReplaceFastStringOLD(implicit context: Context)(
      regexp: FastJSRegExp, string: String, replaceString: String): String {
    // The fast path is reached only if {receiver} is an unmodified JSRegExp
    // instance, {replace_value} is non-callable, and ToString({replace_value})
    // does not contain '$', i.e. we're doing a simple string replacement.
    let result: String = kEmptyString;
    let lastMatchEnd: Smi = 0;
    let unicode: bool = false;
    let replaceLength: Smi = replaceString.length_smi;
    const global: bool = regexp.global;

    if (global) {
      unicode = regexp.unicode;
      regexp.lastIndex = 0;
    }

    while (true) {
      const match: RegExpMatchInfo = RegExpPrototypeExecBodyWithoutResult(
          regexp, string, true) otherwise break;
      const matchStart: Smi = match.GetStartOfCapture(0);
      const matchEnd: Smi = match.GetEndOfCapture(0);

      // TODO(jgruber): We could skip many of the checks that using SubString
      // here entails.
      result = result + SubString(string, lastMatchEnd, matchStart);
      lastMatchEnd = matchEnd;

      if (replaceLength != 0) result = result + replaceString;

      // Non-global case ends here after the first replacement.
      if (!global) break;

      // If match is the empty string, we have to increment lastIndex.
      if (matchEnd == matchStart) {
        AdvanceLastIndex(regexp, string);
      }
    }

    return result + SubString(string, lastMatchEnd, string.length_smi);
  }

  transitioning builtin RegExpReplace(implicit context: Context)(
      regexp: FastJSRegExp, string: String, replaceValue: Object): String {
    // TODO(pwong): Remove assert when all callers (StringPrototypeReplace) are
    // from Torque.
    assert(Is<FastJSRegExp>(regexp));

    // 2. Is {replace_value} callable?
    typeswitch (replaceValue) {
      case (replaceFn: Callable): {
        return regexp.global ?
            RegExpReplaceFastGlobalCallable(regexp, string, replaceFn) :
            StringReplaceNonGlobalRegExpWithFunction(string, regexp, replaceFn);
      }
      case (Object): {
        const stableRegexp: JSRegExp = regexp;
        const replaceString: String = ToString_Inline(context, replaceValue);
        try {
          // ToString(replaceValue) could potentially change the shape of the
          // RegExp object. Recheck that we are still on the fast path and bail
          // to runtime otherwise.
          const fastRegexp = Cast<FastJSRegExp>(stableRegexp) otherwise Runtime;
          if (StringIndexOf(
                  replaceString, SingleCharacterStringConstant('$'), 0) != -1) {
            goto Runtime;
          }

          // let processor: Processor =
          //     NewProcessorForSimpleStringReplacement(stableRegexp);
          // return processor.Process(string, replaceString);
          return RegExpReplaceFastString(fastRegexp, string, replaceString);
          // return RegExpReplaceFastStringOLD(fastRegexp, string, replaceString);
        }
        label Runtime deferred {
          return RegExpReplaceRT(context, stableRegexp, string, replaceString);
        }
      }
    }
  }

  transitioning javascript builtin RegExpPrototypeReplace(
      context: Context, receiver: Object, ...arguments): Object {
    const methodName: constexpr string = 'RegExp.prototype.@@replace';

    // RegExpPrototypeReplace is a bit of a beast - a summary of dispatch logic:
    //
    // if (!IsFastRegExp(receiver)) CallRuntime(RegExpReplace)
    // if (IsCallable(replace)) {
    //   if (IsGlobal(receiver)) {
    //     // Called 'fast-path' but contains several runtime calls.
    //     RegExpReplaceFastGlobalCallable()
    //   } else {
    //     CallRuntime(StringReplaceNonGlobalRegExpWithFunction)
    //   }
    // } else {
    //   if (replace.contains("$")) {
    //     CallRuntime(RegExpReplace)
    //   } else {
    //     RegExpReplaceImpl()
    //   }
    // }

    const string: Object = arguments[0];
    const replaceValue: Object = arguments[1];

    // Let rx be the this value.
    // If Type(rx) is not Object, throw a TypeError exception.
    const rx = Cast<JSReceiver>(receiver)
        otherwise ThrowTypeError(kIncompatibleMethodReceiver, methodName);

    // Let S be ? ToString(string).
    const s = ToString_Inline(context, string);

    // Fast-path checks: 1. Is the {receiver} an unmodified JSRegExp instance?
    try {
      const fastRx: FastJSRegExp = Cast<FastJSRegExp>(rx) otherwise Runtime;
      return RegExpReplace(fastRx, s, replaceValue);
    }
    label Runtime deferred {
      return RegExpReplaceRT(context, rx, s, replaceValue);
    }
  }

}
